<!doctypehtml><html lang="zh-Hant"style="scroll-behavior:smooth"><meta name="twitter:image"content="https://wellstsai.com/single-page-conclusion/ArrayList-vs-LinkedList-%E6%AF%94%E8%BC%83-%E6%95%88%E8%83%BD-%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F.png"><meta name="twitter:description"content="比較資料結構 ArrayList 與 LinkedList 的核心差異，從內部記憶體結構、操作原理到時間複雜度。探討 CPU 快取對真實世界效能的影響，並提供在不同開發場景下的選擇建議與實務指南。"><meta name="twitter:title"content="ArrayList vs LinkedList 比較-效能-使用時機"><meta name="twitter:card"content="summary_large_image"><meta property="og:type"content="article"><meta property="og:site_name"content="WellWells"><meta property="og:image"content="https://wellstsai.com/single-page-conclusion/ArrayList-vs-LinkedList-%E6%AF%94%E8%BC%83-%E6%95%88%E8%83%BD-%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F.png"><meta property="og:url"content="https://wellstsai.com/single-page-conclusion/ArrayList-vs-LinkedList-%E6%AF%94%E8%BC%83-%E6%95%88%E8%83%BD-%E4%BD%BF%E7%94%A8%E6%99%82%E6%A9%9F.html"><meta property="og:description"content="比較資料結構 ArrayList 與 LinkedList 的核心差異，從內部記憶體結構、操作原理到時間複雜度。探討 CPU 快取對真實世界效能的影響，並提供在不同開發場景下的選擇建議與實務指南。"><meta property="og:title"content="ArrayList vs LinkedList 比較-效能-使用時機"><meta name="description"content="比較資料結構 ArrayList 與 LinkedList 的核心差異，從內部記憶體結構、操作原理到時間複雜度。探討 CPU 快取對真實世界效能的影響，並提供在不同開發場景下的選擇建議與實務指南。"><meta charset="UTF-8"><meta name="viewport"content="width=device-width,initial-scale=1"><title>ArrayList vs LinkedList 比較-效能-使用時機</title><script src="https://cdn.tailwindcss.com"></script><script src="https://cdn.jsdelivr.net/npm/chart.js"></script><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap"rel="stylesheet"><style>body{font-family:'Noto Sans TC',sans-serif;background-color:#fdfbf8;color:#4a4a4a}.nav-link{transition:color .3s,border-bottom-color .3s;border-bottom:2px solid transparent}.nav-link.active,.nav-link:hover{color:#d97706;border-bottom-color:#d97706}.btn{background-color:#fbbf24;color:#4a4a4a;transition:background-color .3s,transform .2s}.btn:hover:not(:disabled){background-color:#f59e0b;transform:translateY(-2px)}.btn:disabled{opacity:.5;cursor:not-allowed}.chart-container{position:relative;width:100%;max-width:600px;margin-left:auto;margin-right:auto;height:300px;max-height:400px}@media (min-width:768px){.chart-container{height:350px}}.memory-block{border:1px solid #d1d5db;display:flex;align-items:center;justify-content:center;font-family:monospace;font-size:.8rem;transition:all .3s ease-in-out}.node{background-color:#fff;border:2px solid #fbbf24;border-radius:8px;padding:8px;min-width:60px;text-align:center;position:absolute;box-shadow:0 4px 6px rgba(0,0,0,.1)}.pointer{position:absolute;height:2px;background-color:#d97706;transform-origin:left center}section{padding-top:4rem;padding-bottom:4rem}@media (min-width:768px){section{padding-top:5rem;padding-bottom:5rem}}.keyword{color:#d97706;font-weight:600;cursor:pointer;position:relative;text-decoration:none;transition:background-color .2s ease-in-out,transform .2s ease-in-out;padding:0 2px;border-radius:3px}.keyword:hover{background-color:#fef3c7;transform:scale(1.05)}.keyword::after{content:'';position:absolute;width:100%;height:2px;bottom:-2px;left:0;background-image:linear-gradient(to right,#fbbf24,#d97706);transform:scaleX(0);transform-origin:left center;transition:transform 250ms ease-out}.keyword:focus-visible::after,.keyword:hover::after{transform:scaleX(1)}@media (prefers-reduced-motion:reduce){.keyword::after{transform:scaleX(1);transition:none}.keyword:hover{transform:none}}.modal-backdrop{position:fixed;inset:0;background-color:rgba(0,0,0,.5);opacity:0;transition:opacity .3s ease-in-out;pointer-events:none;z-index:999}.modal-container{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;opacity:0;transform:scale(.95);transition:opacity .3s ease-in-out,transform .3s ease-in-out;pointer-events:none;z-index:1000}.modal-panel{background-color:rgba(255,255,255,.7);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,.2);border-radius:1.5rem;padding:2rem;width:90%;max-width:500px;box-shadow:0 20px 25px -5px rgb(0 0 0 / .1),0 8px 10px -6px rgb(0 0 0 / .1);position:relative}.modal-open .modal-backdrop,.modal-open .modal-container{opacity:1;transform:scale(1);pointer-events:auto}.content-blur>:not(.modal-backdrop,.modal-container){filter:blur(5px);transition:filter .3s ease-in-out}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-JKC4KZLT26"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JKC4KZLT26")</script><body class="antialiased"><header class="bg-white/80 backdrop-blur-md sticky top-0 z-50 shadow-sm"><nav class="container mx-auto px-6 py-4 flex justify-between items-center"><h1 class="text-2xl font-bold text-amber-600">ArrayList vs. LinkedList</h1><div class="hidden md:flex space-x-8"><a href="#intro"class="nav-link active pb-1">陣列的基礎</a> <a href="#comparison"class="nav-link pb-1">核心結構比較</a> <a href="#performance"class="nav-link pb-1">效能分析</a> <a href="#implementation"class="nav-link pb-1">語言中的實作</a></div><button id="mobile-menu-button"class="md:hidden p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-amber-500"><svg class="w-6 h-6"fill="none"stroke="currentColor"viewBox="0 0 24 24"xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round"stroke-linejoin="round"stroke-width="2"d="M4 6h16M4 12h16m-4 6h4"></path></svg></button></nav><div id="mobile-menu"class="hidden md:hidden px-6 pb-4 space-y-2"><a href="#intro"class="block nav-link active py-2">陣列的基礎</a> <a href="#comparison"class="block nav-link py-2">核心結構比較</a> <a href="#performance"class="block nav-link py-2">效能分析</a> <a href="#implementation"class="block nav-link py-2">語言中的實作</a></div></header><main class="container mx-auto p-4 md:p-8"><section id="intro"><h2 class="text-3xl font-bold mb-4 text-amber-700">陣列的基礎：固定與連續</h2><p class="mb-6 text-lg text-gray-700 max-w-3xl mx-auto">在深入探討 ArrayList 和 LinkedList 之前，我們必須先理解<span class="keyword"data-term="traditional-array">傳統陣列</span>的本質。在像 C 這樣的系統程式語言中，陣列是一塊<span class="keyword"data-term="contiguous">連續</span>且<span class="keyword"data-term="fixed-size">大小固定</span>的記憶體空間。這兩個特性是它們所有行為的根源，也正是動態資料結構試圖解決的問題。<div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200 mt-8 max-w-4xl mx-auto"><h3 class="text-xl font-bold mb-4">記憶體中的陣列</h3><p class="mb-4">陣列中的每個元素在記憶體中緊密相鄰。這使得電腦可以透過一個簡單的數學公式快速存取任何元素：<code class="bg-amber-100 text-amber-800 rounded px-2 py-1">目標位址 = 基底位址 + (索引 * 元素大小)</code>。這就是為什麼陣列的索引是從 0 開始，因為第一個元素的位址就是基底位址本身。<div class="flex items-center space-x-4 mb-4"><div><label for="array-index-input"class="block text-sm font-medium text-gray-700">選擇索引：</label> <input type="number"id="array-index-input"value="2"min="0"max="4"class="mt-1 block w-24 rounded-md border-gray-300 shadow-sm focus:border-amber-500 focus:ring-amber-500 sm:text-sm"></div><div id="address-calculation"class="text-lg font-mono pt-6"></div></div><div id="static-array-vis"class="grid grid-cols-5 gap-1 bg-gray-100 p-2 rounded-md"></div><p id="index-error-msg"class="text-red-600 mt-2 font-bold h-6"><p class="text-sm text-gray-500 mt-4">這個設計的缺點是：陣列一旦宣告，其大小就無法改變。試圖存取超出邊界的索引會導致「<span class="keyword"data-term="buffer-overflow">緩衝區溢位</span>」(Buffer Overflow) 或「<span class="keyword"data-term="segmentation-fault">分段錯誤</span>」(Segmentation Fault)，這是系統程式中常見且危險的錯誤。</div></section><hr class="border-t-2 border-amber-100 my-8"><section id="comparison"><h2 class="text-3xl font-bold mb-4 text-amber-700">核心結構比較</h2><p class="mb-6 text-lg text-gray-700 max-w-3xl mx-auto">為了解決傳統陣列大小固定的問題，我們引入了兩種主要的動態資料結構：<span class="keyword"data-term="arraylist">ArrayList</span> (在 Rust 中稱為 Vector) 和 <span class="keyword"data-term="linkedlist">LinkedList</span>。它們都允許元素數量動態增長，但實現方式和效能特性截然不同。<div class="grid md:grid-cols-2 gap-8 mt-8"><div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200"><h3 class="text-2xl font-bold mb-4">ArrayList: 智慧型陣列</h3><p class="mb-4">ArrayList 內部仍然使用一個傳統陣列來儲存資料。它的「智慧」之處在於它會追蹤目前的<span class="keyword"data-term="length">長度 (length)</span> 和<span class="keyword"data-term="capacity">容量 (capacity)</span>。當陣列被填滿時，它會自動建立一個更大的新陣列 (通常是兩倍大)，將舊陣列的元素複製過去，然後釋放舊陣列。<div class="mb-4 space-x-2"><button id="al-push-btn"class="btn px-4 py-2 rounded-lg font-semibold">Push</button> <button id="al-remove-btn"class="btn px-4 py-2 rounded-lg font-semibold">Remove (at index 2)</button> <button id="al-reset-btn"class="btn bg-gray-300 hover:bg-gray-400 px-4 py-2 rounded-lg font-semibold">Reset</button></div><div id="array-list-info"class="font-mono text-sm mb-2"></div><div id="array-list-vis"class="relative bg-gray-100 p-2 rounded-md min-h-[120px]"></div><p id="al-op-status"class="mt-2 text-sm text-gray-600 h-10"></div><div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200"><h3 class="text-2xl font-bold mb-4">LinkedList: 節點鏈</h3><p class="mb-4">LinkedList 完全放棄了連續記憶體的概念。它由一系列的「節點」組成，每個節點包含一個元素和一個指向下一個節點的<span class="keyword"data-term="pointer">指標 (pointer)</span>。這些節點可以散布在記憶體的任何地方。<div class="mb-4 space-x-2"><button id="ll-push-btn"class="btn px-4 py-2 rounded-lg font-semibold">Push</button> <button id="ll-remove-btn"class="btn px-4 py-2 rounded-lg font-semibold">Remove (at index 2)</button> <button id="ll-reset-btn"class="btn bg-gray-300 hover:bg-gray-400 px-4 py-2 rounded-lg font-semibold">Reset</button></div><div id="linked-list-info"class="font-mono text-sm mb-2"></div><div id="linked-list-vis"class="relative p-2 min-h-[180px] h-64"></div><p id="ll-op-status"class="mt-2 text-sm text-gray-600 h-10"></div></div></section><hr class="border-t-2 border-amber-100 my-8"><section id="performance"><h2 class="text-3xl font-bold mb-4 text-amber-700">效能分析：速度的戰爭</h2><p class="mb-6 text-lg text-gray-700 max-w-3xl mx-auto">結構上的差異直接導致了巨大的效能差異。在現代電腦架構中，這不僅僅是演算法複雜度的問題，更重要的是<span class="keyword"data-term="cpu-cache">CPU 快取 (Cache)</span> 的影響。<div class="grid md:grid-cols-2 gap-8 mt-8"><div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200"><h3 class="text-xl font-bold mb-2"><span class="keyword"data-term="big-o">時間複雜度 (Big O)</span></h3><p class="mb-4">下圖比較了幾種關鍵操作的平均時間複雜度。<div class="chart-container"><canvas id="big-o-chart"></canvas></div></div><div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200"><h3 class="text-xl font-bold mb-2">CPU 快取：真正的效能關鍵</h3><p class="mb-4">CPU 快取是位於 CPU 內部的一小塊超高速記憶體。當 CPU 需要資料時，如果資料在快取中 (快取命中)，速度會極快。如果不在 (快取失誤)，CPU 就必須從慢得多的主記憶體中讀取，造成巨大延遲。<div class="space-y-4"><div><h4 class="font-semibold text-lg text-green-600">ArrayList: 快取友好</h4><p>由於元素在記憶體中是連續的，當 CPU 讀取一個元素時，它會順便將鄰近的元素也載入快取。這大大提高了「快取命中率」，使得循序存取非常快。</div><div><h4 class="font-semibold text-lg text-red-600">LinkedList: 快取災難</h4><p>節點散布在記憶體各處。存取一個節點後，下一個節點極不可能在快取中，導致大量的「快取失誤」。這使得遍歷 LinkedList 的速度遠比理論上看起來要慢。</div></div></div></div></section><hr class="border-t-2 border-amber-100 my-8"><section id="implementation"><h2 class="text-3xl font-bold mb-4 text-amber-700">高階語言中的實作</h2><p class="mb-6 text-lg text-gray-700 max-w-3xl mx-auto">像 JavaScript 和 Python 這樣的腳本語言為開發者提供了極大的便利，它們的「陣列」或「列表」似乎結合了所有優點。但這只是表象，其底層是透過更複雜的資料結構來「模擬」陣列行為的。<div class="grid md:grid-cols-2 gap-8 mt-8"><div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200"><h3 class="text-2xl font-bold mb-4">Python 的 <code class="bg-amber-100 text-amber-800 rounded px-2 py-1">list</code></h3><p class="mb-4">Python 的 <code class="text-sm">list</code> 實際上是一個 ArrayList，但它儲存的不是值本身，而是指向物件的<span class="keyword"data-term="pointer">指標 (或參照)</span>。這就是為什麼 Python 列表可以儲存不同類型的資料——因為所有指標的大小都是相同的。<div class="bg-gray-100 p-4 rounded-md"><p class="font-mono text-sm">my_list = [10, "hello", True]<p class="text-xs mt-2 text-gray-600">↳ 內部是一個指標陣列，分別指向一個整數物件、一個字串物件和一個布林物件。</div><p class="mt-4 text-sm text-gray-600">這種設計雖然靈活，但因為需要二次定址 (先找到指標，再透過指標找到物件)，對快取效能有一定影響，比不上 C++ 或 Rust 中儲存原始值的 Vector。</div><div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200"><h3 class="text-2xl font-bold mb-4">JavaScript 的 <code class="bg-amber-100 text-amber-800 rounded px-2 py-1">Array</code></h3><p class="mb-4">JavaScript 的陣列更加奇特，它甚至<span class="font-semibold text-red-600">不是真正的陣列</span>！本質上，它是一個<span class="keyword"data-term="hash-map">雜湊表 (Hash Map)</span>，其中鍵是索引的字串形式。這只是 JavaScript 引擎提供的語法糖。<div class="bg-gray-100 p-4 rounded-md"><p class="font-mono text-sm">let arr = [];<p class="font-mono text-sm">arr[1000] = 'value';<p class="text-xs mt-2 text-gray-600">↳ 引擎並不會分配一個包含 1001 個元素的陣列，而只是在雜湊表中插入一個鍵值對 <code class="text-sm">{'1000': 'value'}</code>。</div><p class="mt-4 text-sm text-gray-600">這解釋了為什麼 JS 陣列可以有非連續的索引。不過，現代 JS 引擎會進行優化：如果偵測到你像使用傳統陣列一樣使用它 (連續的、數字索引)，引擎會在底層切換到更高效的類陣列實作來提升效能。</div></div></section><hr class="border-t-2 border-amber-100 my-8"><section id="summary"><h2 class="text-3xl font-bold mb-4 text-amber-700">總結與實務建議</h2><p class="mb-6 text-lg text-gray-700 max-w-3xl mx-auto">理論知識固然重要，但在實際的軟體開發中，我們更關心何時該用哪種資料結構。以下是一些來自實務經驗的總結。<div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200 mt-8 max-w-4xl mx-auto space-y-4"><p><strong class="keyword"data-term="linkedlist">LinkedList</strong> 是由一連串節點串連起來，適合在<strong class="text-amber-600">頭尾進行快速新增和刪除</strong>操作；但因為無法隨機存取（不能像陣列一樣直接依索引找到元素），尋找中間元素的時間較長。<p>實務上，許多開發者更常用 <strong class="keyword"data-term="arraylist">ArrayList</strong>（動態陣列），因其<strong class="text-amber-600">快取效能較好</strong>，在大多數情況下整體速度反而優於 LinkedList。有趣的是，就連 Java 集合框架中 LinkedList 的作者都表示自己很少用它，且許多情況可以使用更有效率的結構（如 <strong class="keyword"data-term="arraydeque">ArrayDeque</strong>）替代。<p>若您是初學者，不必擔心。可以先從理解其結構、操作（增刪查改）和使用場合開始，再透過 LeetCode 等題目練習相關演算法，會更容易掌握。</div><div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200 mt-8 max-w-4xl mx-auto"><h3 class="text-2xl font-bold mb-4">在什麼情況下使用 LinkedList 最合適？</h3><ul class="list-disc list-inside space-y-3 text-gray-700"><li><strong class="text-amber-600">大量頻繁的新增或刪除操作：</strong> 特別是在列表的<strong class="text-amber-600">頭部或中間</strong>。LinkedList 在這些位置插入和刪除節點的時間複雜度為 O(1)（若有指向該節點的參考），不需要像 ArrayList 一樣搬移後續所有元素。<li><strong class="text-amber-600">資料大小不固定或無法事先預估：</strong> LinkedList 可動態擴充節點，不像陣列需要耗費較大成本來重新分配空間與複製元素。<li><strong class="text-amber-600">實現特定的抽象資料結構：</strong> 如<strong class="keyword"data-term="stack">堆疊 (Stack)</strong>、<strong class="keyword"data-term="queue">佇列 (Queue)</strong> 或圖的鄰接表，這些結構常利用 LinkedList 的特性來實作，以便進行靈活的插入和刪除。<li><strong class="text-amber-600">不需要頻繁隨機存取資料：</strong> 如果您的主要操作是循序遍歷，而不是透過索引跳躍式地存取元素，那麼 LinkedList 的缺點就不那麼明顯。<li><strong class="text-amber-600">記憶體管理應用：</strong> 某些系統內部管理空閒記憶體塊時，也會使用 LinkedList 追蹤離散的記憶體區塊。</ul><p class="mt-6 font-semibold">綜合來說：若應用需求是<strong class="text-green-600">頻繁插入/刪除</strong>且<strong class="text-red-600">不強調快速隨機存取</strong>，LinkedList 是較佳選擇。反之，若需要<strong class="text-green-600">快速隨機讀取</strong>，則陣列或 ArrayList 更合適。</div></section></main><div id="keyword-modal-backdrop"class="modal-backdrop"></div><div id="keyword-modal-container"class="modal-container"role="dialog"aria-modal="true"><div class="modal-panel"><h3 id="modal-title"class="text-2xl font-bold text-amber-800 mb-4"></h3><div id="modal-content"class="text-gray-700 space-y-3"></div><button id="modal-close-btn"class="absolute top-4 right-4 text-gray-500 hover:text-gray-800 transition-colors"><svg class="w-6 h-6"fill="none"stroke="currentColor"viewBox="0 0 24 24"xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round"stroke-linejoin="round"stroke-width="2"d="M6 18L18 6M6 6l12 12"></path></svg></button></div></div><footer class="bg-gray-800 text-gray-300 py-8 mt-16"><div class="container mx-auto text-center"><a href="https://wellstsai.com"target="_blank"rel="noopener noreferrer"class="text-amber-400 hover:text-amber-300 transition-colors duration-300 text-lg">Generated by wellstsai.com</a><p class="text-sm text-gray-400 mt-2">撰寫日期：2025 年 9 月 10 日</div></footer><script>document.addEventListener("DOMContentLoaded",()=>{const t=document.getElementById("mobile-menu-button"),e=document.getElementById("mobile-menu"),n=document.querySelectorAll(".nav-link"),o=document.querySelectorAll("main > section");t.addEventListener("click",()=>{e.classList.toggle("hidden"),e.classList.toggle("block")}),n.forEach(t=>{t.addEventListener("click",()=>{e.classList.contains("block")&&(e.classList.remove("block"),e.classList.add("hidden"))})});const l=new IntersectionObserver(t=>{t.forEach(t=>{if(t.isIntersecting){const e=t.target.getAttribute("id");document.querySelectorAll(".nav-link").forEach(t=>{t.classList.remove("active"),t.getAttribute("href")===`#${e}`&&t.classList.add("active")})}})},{rootMargin:"-40% 0px -60% 0px"});o.forEach(t=>{l.observe(t)});const a=document.getElementById("static-array-vis"),i=document.getElementById("array-index-input"),s=document.getElementById("address-calculation"),d=document.getElementById("index-error-msg"),r=[10,20,30,40,50];function c(){const t=parseInt(i.value);if(d.textContent="",document.querySelectorAll("#static-array-vis .memory-block").forEach(t=>{t.style.backgroundColor="#F3F4F6",t.style.borderColor="#D1D5DB"}),isNaN(t))s.textContent="";else if(t>=0&&t<5){const e=document.querySelector(`#static-array-vis .memory-block[data-index='${t}']`);e&&(e.style.backgroundColor="#FEF3C7",e.style.borderColor="#FBBF24"),s.textContent=`1000 + (${t} * 4) = ${1e3+4*t}`}else s.textContent="存取越界！",d.textContent="錯誤：索引超出陣列邊界！"}i.addEventListener("input",c),function(){a.innerHTML="";for(let t=0;t<5;t++){const e=document.createElement("div");e.className="memory-block h-16",e.dataset.index=t,e.innerHTML=`<div class="text-center">\n                <div class="font-bold text-lg">${r[t]}</div>\n                <div class="text-xs text-gray-500">[${t}]</div>\n            </div>`,a.appendChild(e)}}(),c();let u={capacity:4,length:0,elements:[],opCounter:0};const m=document.getElementById("array-list-vis"),p=document.getElementById("array-list-info"),g=document.getElementById("al-op-status");function y(){m.innerHTML="",m.style.gridTemplateColumns=`repeat(${u.capacity}, minmax(0, 1fr))`,m.classList.add("grid","gap-1");for(let t=0;t<u.capacity;t++){const e=document.createElement("div");e.className="memory-block h-12 text-sm",t<u.length?(e.textContent=u.elements[t],e.style.backgroundColor="#FEF3C7"):(e.style.backgroundColor="#E5E7EB",e.classList.add("text-gray-400")),e.dataset.index=t,m.appendChild(e)}p.textContent=`Length: ${u.length} | Capacity: ${u.capacity}`}function h(){u={capacity:4,length:0,elements:[],opCounter:0},g.textContent="",y()}document.getElementById("al-push-btn").addEventListener("click",()=>{u.opCounter++;const t=10*u.opCounter;if(g.textContent=`Pushing ${t}...`,u.length===u.capacity){g.textContent=`Array is full. Resizing from ${u.capacity} to ${2*u.capacity}...`;u.capacity;u.capacity*=2;const e=new Array(u.capacity);for(let t=0;t<u.length;t++)e[t]=u.elements[t];setTimeout(()=>{g.textContent="Copying elements to new array...",y(),setTimeout(()=>{u.elements.push(t),u.length++,g.textContent=`Pushed ${t}.`,y()},1e3)},1e3)}else u.elements.push(t),u.length++,g.textContent=`Pushed ${t}.`,y()}),document.getElementById("al-remove-btn").addEventListener("click",()=>{if(u.length<=2)return void(g.textContent="Cannot remove at index 2. Not enough elements.");const t=u.elements[2];g.textContent=`Removing ${t} at index 2...`;m.querySelector("[data-index='2']").style.backgroundColor="#FECACA",setTimeout(()=>{g.textContent="Shifting subsequent elements...";let e=0;for(let t=2;t<u.length-1;t++)e++,u.elements[t]=u.elements[t+1];u.length--,u.elements.pop(),y(),setTimeout(()=>{g.textContent=`Removed ${t}. Shifted ${e} element(s).`},500)},1e3)}),document.getElementById("al-reset-btn").addEventListener("click",h);let C={head:null,length:0,opCounter:0};const x=document.getElementById("linked-list-vis"),f=document.getElementById("linked-list-info"),b=document.getElementById("ll-op-status");function v(){const t=document.getElementById("ll-push-btn");C.length>=8?t.disabled=!0:t.disabled=!1}function E(){x.innerHTML="",f.textContent=`Length: ${C.length}`;let t=C.head,e=0;for(;t;){const n=document.createElement("div");n.className="node transition-all duration-500",n.textContent=t.value;const o=24*(e%4)+4,l=75*Math.floor(e/4)+20;n.style.left=`${o}%`,n.style.top=`${l}px`,t.el=n,x.appendChild(n),e++,t=t.next}setTimeout(()=>{for(t=C.head;t&&t.next;){const e=t.el,n=t.next.el,o=e.getBoundingClientRect(),l=n.getBoundingClientRect(),a=x.getBoundingClientRect(),i=o.left-a.left+o.width/2,s=o.top-a.top+o.height/2,d=l.left-a.left+l.width/2,r=l.top-a.top+l.height/2,c=180*Math.atan2(r-s,d-i)/Math.PI,u=Math.sqrt(Math.pow(d-i,2)+Math.pow(r-s,2)),m=document.createElement("div");m.className="pointer";const p=e.offsetWidth,g=u-p;m.style.width=`${g>0?g:0}px`,m.style.left=`${i}px`,m.style.top=`${s}px`,m.style.transform=`rotate(${c}deg) translateX(${p/2}px)`,x.insertBefore(m,x.firstChild),t=t.next}},50)}function L(){C={head:null,length:0,opCounter:0},b.textContent="",E(),v()}document.getElementById("ll-push-btn").addEventListener("click",()=>{if(C.length>=8)return void(b.textContent="已達到最大節點數量 (8)。");C.opCounter++;const t=10*C.opCounter;b.textContent=`Pushing ${t}...`;const e={value:t,next:null};if(C.head){let t=C.head;for(;t.next;)t=t.next;t.next=e}else C.head=e;C.length++,E(),v(),setTimeout(()=>{b.textContent=`Pushed ${t}.`},300)}),document.getElementById("ll-remove-btn").addEventListener("click",()=>{if(C.length<=2)return void(b.textContent="Cannot remove at index 2. Not enough elements.");b.textContent="Traversing to index 2...";let t=0,e=C.head;const n=setInterval(()=>{t>2||!e?clearInterval(n):(e.el&&(e.el.style.borderColor="#34D399"),e=e.next,t++)},400);setTimeout(()=>{let e;clearInterval(n);{let n=C.head,o=null;for(t=0;t<2;)o=n,n=n.next,t++;e=n.value,o.next=n.next}C.length--,b.textContent=`Removing ${e}. Updating pointer...`,E(),v(),setTimeout(()=>{b.textContent=`Removed ${e}. No shifting needed.`},500)},1600)}),document.getElementById("ll-reset-btn").addEventListener("click",L),h(),L();const k=document.getElementById("big-o-chart").getContext("2d");new Chart(k,{type:"bar",data:{labels:["Access (by index)","Insert/Remove (end)","Insert/Remove (middle)"],datasets:[{label:"ArrayList",data:[1,1,10],backgroundColor:"rgba(251, 191, 36, 0.6)",borderColor:"rgba(251, 191, 36, 1)",borderWidth:1},{label:"LinkedList",data:[10,1,1],backgroundColor:"rgba(59, 130, 246, 0.6)",borderColor:"rgba(59, 130, 246, 1)",borderWidth:1}]},options:{maintainAspectRatio:!1,scales:{y:{beginAtZero:!0,ticks:{callback:function(t){return 1===t?"O(1) - 快":10===t?"O(n) - 慢":""}}}},plugins:{tooltip:{callbacks:{label:function(t){let e=t.dataset.label||"";e&&(e+=": ");const n=t.parsed.y;if(1===n){if("LinkedList"===t.dataset.label&&1===t.dataIndex)return e+"O(1) (如果維持 tail 指標)";e+="O(1) (常數時間)"}if(10===n){if("LinkedList"===t.dataset.label&&1===t.dataIndex)return e+"O(n) (如果沒有 tail 指標)";e+="O(n) (線性時間)"}return e}}},legend:{position:"top"},title:{display:!0,text:"時間複雜度比較"}}}});const I={"traditional-array":{title:"傳統陣列 (Array)",content:'<p>一種基礎資料結構，由相同類型的元素組成，並儲存在一塊<strong>連續的記憶體</strong>中。其大小在建立時就已固定，無法動態改變。</p><p>由於記憶體連續，可以透過 <code class="bg-gray-200 text-sm rounded px-1">基底位址 + 索引 * 元素大小</code> 的公式進行 O(1) 時間複雜度的快速隨機存取。</p>'},contiguous:{title:"連續 (Contiguous)",content:"<p>指資料在記憶體中的儲存方式是緊密相鄰的，一個元素接著下一個，中間沒有任何間隙。</p><p>這個特性是陣列（及 ArrayList）能實現快速索引存取的關鍵，同時也對 CPU 快取非常友好，因為讀取一個元素時，其鄰近的元素很可能也被一起載入快取中。</p>"},"fixed-size":{title:"大小固定 (Fixed-size)",content:"<p>指資料結構在宣告或建立時，其容量就已經確定，並且在後續操作中無法改變。這是傳統陣列最主要的限制。</p><p>若要儲存更多元素，必須建立一個全新的、更大的陣列，並將舊陣列的內容複製過去，成本較高。</p>"},arraylist:{title:"ArrayList (動態陣列)",content:"<p>一種可以動態增長大小的列表結構。其內部仍然使用一個傳統陣列來儲存元素。</p><p>當內部陣列被填滿時，它會自動進行「擴容」：建立一個更大的新陣列（通常是原來的 1.5 倍或 2 倍大），將所有舊元素複製到新陣列，然後釋放舊陣列的記憶體。這個過程雖然有成本，但其分攤時間複雜度 (Amortized Time Complexity) 仍然是 O(1)。</p>"},linkedlist:{title:"LinkedList (鏈結串列)",content:"<p>一種線性資料結構，由一系列「節點 (Node)」組成。每個節點包含兩部分：儲存的資料，以及一個指向下一個節點的參考（指標）。</p><p>節點在記憶體中可以是不連續的，這使得它在插入和刪除元素時非常高效（只需修改前後節點的指標），但犧牲了快速隨機存取的能力（必須從頭部開始逐一走訪）。</p>"},length:{title:"長度 (Length)",content:"<p>表示資料結構中目前實際包含的元素數量。例如，一個容量為 10 的 ArrayList，如果只裝了 3 個元素，其長度就是 3。</p>"},capacity:{title:"容量 (Capacity)",content:"<p>表示資料結構內部儲存空間的大小，也就是在不需重新分配記憶體的情況下，最多可以容納的元素數量。</p><p>這個概念主要用於 ArrayList 等基於陣列的結構。當 Length 等於 Capacity 時，若要再新增元素，就必須進行擴容。</p>"},pointer:{title:"指標 (Pointer)",content:"<p>一個變數，其值是另一個變數的記憶體位址。在 LinkedList 中，每個節點內的指標儲存著下一個節點的記憶體位置，從而將所有離散的節點「鏈結」起來。</p><p>在高階語言如 Python 或 Java 中，這個概念通常被抽象化為「參照 (Reference)」。</p>"},"cpu-cache":{title:"CPU 快取 (Cache)",content:"<p>位於 CPU 和主記憶體 (RAM) 之間的一小塊高速靜態記憶體 (SRAM)。由於 CPU 的運算速度遠高於主記憶體的讀寫速度，快取被用來儲存最常被存取的資料，以減少 CPU 等待資料的延遲。</p><p>當資料在快取中被找到，稱為「快取命中 (Cache Hit)」，速度極快；反之稱為「快取失誤 (Cache Miss)」，需要從慢速的主記憶體讀取，效能損失巨大。</p>"},"big-o":{title:"時間複雜度 (Big O Notation)",content:"<p>一種用來衡量演算法執行時間（或空間需求）如何隨著輸入資料量 n 的增長而變化的數學表示法。它描述了演算法效能的「最壞情況」或「上限」。</p><p>常見的 Big O 包括：O(1) 常數時間、O(log n) 對數時間、O(n) 線性時間、O(n²)、O(2ⁿ) 等。數字越小代表演算法越有效率。</p>"},"hash-map":{title:"雜湊表 (Hash Map)",content:"<p>一種透過「鍵 (Key)」來直接存取「值 (Value)」的資料結構。它使用一個雜湊函數 (Hash Function) 將鍵轉換為陣列的索引，從而實現接近 O(1) 的快速查詢、插入和刪除操作。</p><p>JavaScript 的 Array 在本質上更像一個經過優化的雜湊表，這也是它可以使用非連續或非數字索引的原因。</p>"},arraydeque:{title:"ArrayDeque",content:"<p>一種雙端佇列 (Double-Ended Queue)，通常由環狀陣列 (Circular Array) 實現。它允許在佇列的頭部和尾部都進行 O(1) 時間複雜度的插入和刪除操作。</p><p>在許多需要佇列或堆疊功能的場景下，ArrayDeque 因其更好的局部性和快取效能，通常比 LinkedList 更為高效。</p>"},stack:{title:"堆疊 (Stack)",content:"<p>一種遵循「後進先出 (Last-In, First-Out, LIFO)」原則的抽象資料結構。最後被放入的元素會最先被取出，就像一疊盤子一樣。</p><p>主要操作為 Push (推入元素到頂部) 和 Pop (從頂部彈出元素)。</p>"},queue:{title:"佇列 (Queue)",content:"<p>一種遵循「先進先出 (First-In, First-Out, FIFO)」原則的抽象資料結構。最先被放入的元素會最先被取出，就像排隊一樣。</p><p>主要操作為 Enqueue (在尾部加入元素) 和 Dequeue (從頭部移除元素)。</p>"},"buffer-overflow":{title:"緩衝區溢位 (Buffer Overflow)",content:"<p>當程式嘗試向一塊固定大小的記憶體緩衝區寫入超過其容量的資料時發生的錯誤。溢出的資料會覆蓋相鄰的記憶體區域，可能導致程式崩潰、資料損毀，甚至成為一個嚴重的安全漏洞，被駭客用來執行惡意程式碼。</p>"},"segmentation-fault":{title:"分段錯誤 (Segmentation Fault)",content:"<p>當程式試圖存取其無權存取的記憶體區域時，由作業系統的記憶體管理單元 (MMU) 發出的錯誤訊號。常見原因包括存取空指標 (NULL pointer) 或陣列越界存取。這是一種保護機制，防止程式破壞其他程式或作業系統的記憶體空間。</p>"}},B=document.getElementById("keyword-modal-backdrop"),$=(document.getElementById("keyword-modal-container"),document.getElementById("modal-title")),A=document.getElementById("modal-content"),O=document.getElementById("modal-close-btn"),F=document.body;function M(){F.classList.remove("modal-open"),setTimeout(()=>{F.classList.remove("content-blur")},300)}document.querySelectorAll(".keyword").forEach(t=>{t.addEventListener("click",t=>{t.preventDefault();!function(t){const e=I[t];e&&($.textContent=e.title,A.innerHTML=e.content,F.classList.add("modal-open","content-blur"))}(t.target.dataset.term)})}),B.addEventListener("click",M),O.addEventListener("click",M),document.addEventListener("keydown",t=>{"Escape"===t.key&&F.classList.contains("modal-open")&&M()})})</script>