<!doctypehtml><html lang="zh-TW"class="scroll-smooth"><meta name="twitter:image"content="https://wellstsai.com/single-page-conclusion/git-filter-repo%20%E6%95%99%E5%AD%B8%E6%8C%87%E5%8D%97.png"><meta name="twitter:description"content="不小心將密碼或 API 金鑰提交到 Git？本教學引導您使用 git-filter-repo，安全地重寫歷史紀錄，從所有 commit 中徹底清除敏感資訊。"><meta name="twitter:title"content="git-filter-repo 教學指南"><meta name="twitter:card"content="summary_large_image"><meta property="og:type"content="article"><meta property="og:site_name"content="WellWells"><meta property="og:image"content="https://wellstsai.com/single-page-conclusion/git-filter-repo%20%E6%95%99%E5%AD%B8%E6%8C%87%E5%8D%97.png"><meta property="og:url"content="https://wellstsai.com/single-page-conclusion/git-filter-repo%20%E6%95%99%E5%AD%B8%E6%8C%87%E5%8D%97.html"><meta property="og:description"content="不小心將密碼或 API 金鑰提交到 Git？本教學引導您使用 git-filter-repo，安全地重寫歷史紀錄，從所有 commit 中徹底清除敏感資訊。"><meta property="og:title"content="git-filter-repo 教學指南"><meta name="description"content="不小心將密碼或 API 金鑰提交到 Git？本教學引導您使用 git-filter-repo，安全地重寫歷史紀錄，從所有 commit 中徹底清除敏感資訊。"><meta charset="UTF-8"><meta name="viewport"content="width=device-width,initial-scale=1"><title>git-filter-repo 教學指南</title><script src="https://cdn.tailwindcss.com"></script><style>@import url(https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap);body{font-family:Inter,sans-serif;background-color:#fdfbf8;color:#38332e}.nav-link{transition:color .3s ease,border-bottom-color .3s ease;border-bottom:2px solid transparent}.nav-link.active,.nav-link:hover{color:#d97706;border-bottom-color:#d97706}.step-card{background-color:#fff;border:1px solid #eae6e1;border-radius:.75rem;transition:box-shadow .3s ease}.step-card:hover{box-shadow:0 10px 15px -3px rgba(0,0,0,.05),0 4px 6px -2px rgba(0,0,0,.05)}.code-block{background-color:#2d3748;color:#f7fafc;border-radius:.5rem;position:relative;overflow-x:auto}.code-block code{word-wrap:break-word;white-space:pre-wrap}.copy-button{position:absolute;top:.75rem;right:.75rem;background-color:#4a5568;color:#f7fafc;border:none;padding:.25rem .5rem;border-radius:.375rem;cursor:pointer;font-size:.875rem;transition:background-color .2s}.copy-button:hover{background-color:#718096}.checklist-item{display:flex;align-items:center;padding:.75rem;background-color:#f9fafb;border-radius:.5rem;border:1px solid #e5e7eb;cursor:pointer;transition:background-color .2s,border-color .2s}.checklist-item.completed{background-color:#f0fff4;border-color:#9ae6b4;text-decoration:line-through;color:#718096}.checklist-item input[type=checkbox]{display:none}.custom-checkbox{width:1.25rem;height:1.25rem;border:2px solid #d1d5db;border-radius:.25rem;margin-right:.75rem;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:background-color .2s,border-color .2s}.checklist-item.completed .custom-checkbox{background-color:#38a169;border-color:#38a169}.custom-checkbox-tick{display:none;width:.75rem;height:.75rem}.checklist-item.completed .custom-checkbox-tick{display:block}.keyword{color:#c05621;font-weight:600;cursor:pointer;transition:transform .2s ease,background-color .3s ease;padding:2px 4px;border-radius:4px}.keyword:hover{transform:scale(1.05);background-image:linear-gradient(to right,#fef3c7,#fde68a)}.modal-overlay{transition:opacity .3s ease-in-out}.modal-container{transition:opacity .3s ease-in-out,transform .3s ease-in-out}body.modal-open #root-container{filter:blur(5px);transition:filter .3s ease-in-out}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-JKC4KZLT26"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JKC4KZLT26")</script><body class="antialiased"><div id="root-container"><header id="header"class="sticky top-0 z-40 bg-[#FDFBF8]/80 backdrop-blur-lg border-b border-gray-200"><nav class="container mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16"><div class="flex-shrink-0"><h1 class="text-xl font-bold text-amber-700">git-filter-repo 指南</h1></div><div class="hidden md:block"><div class="ml-10 flex items-baseline space-x-4"><a href="#problem"class="nav-link px-3 py-2 rounded-md text-sm font-medium">為何需要</a> <a href="#preparation"class="nav-link px-3 py-2 rounded-md text-sm font-medium">1. 事前準備</a> <a href="#execution"class="nav-link px-3 py-2 rounded-md text-sm font-medium">2. 執行清理</a> <a href="#finalize"class="nav-link px-3 py-2 rounded-md text-sm font-medium">3. 完成與推送</a> <a href="#prevention"class="nav-link px-3 py-2 rounded-md text-sm font-medium">4. 後續防範</a> <a href="#security-warning"class="nav-link px-3 py-2 rounded-md text-sm font-medium">補充說明</a></div></div></div></nav></header><main class="container mx-auto px-4 sm:px-6 lg:px-8 py-8 md:py-12"><section id="problem"class="mb-16 scroll-mt-24"><div class="text-center mb-12"><h2 class="text-3xl font-extrabold text-gray-900 sm:text-4xl">徹底清除 Git 歷史中的敏感資訊</h2><p class="mt-4 text-lg text-gray-600 max-w-3xl mx-auto">不小心將 API 金鑰或密碼提交到 Git？只在最新版本刪除是沒有用的，它們依然存在於歷史紀錄中。本指南將引導您使用 <span class="keyword"data-keyword-id="git-filter-repo">git-filter-repo</span>，安全地重寫歷史，徹底銷毀證據。</div></section><section id="preparation"class="mb-16 scroll-mt-24"><h3 class="text-2xl font-bold mb-6 border-l-4 border-amber-500 pl-4">第一步：事前準備</h3><p class="mb-8 text-gray-700">這是整個流程中最關鍵的環節。若準備不周，可能會導致團隊成員的程式碼遺失或發生嚴重衝突。請務必依序完成以下所有準備工作。<div class="step-card p-6 mb-8 border-amber-500 border-2"><h4 class="text-xl font-semibold mb-4 text-amber-800">步驟 0：立即緊急應對 (最重要！)</h4><div class="space-y-3 text-gray-700"><div class="flex items-start"><span class="text-amber-600 font-bold mr-2">1.</span><div><strong class="text-gray-900">撤銷/汰換憑證：</strong> 對於已曝露的 API key、密碼、token 等，立即到對應的服務平台將它們停用或重設。<strong>這是唯一能真正阻斷風險的步驟。</strong></div></div><div class="flex items-start"><span class="text-amber-600 font-bold mr-2">2.</span><div><strong class="text-gray-900">暫停部署：</strong> 如果您的 <span class="keyword"data-keyword-id="ci/cd">CI/CD</span> 流程會自動取用這些憑證，請立刻暫停，避免自動化系統繼續使用外洩的憑證造成更大損害。</div></div></div></div><div class="grid grid-cols-1 lg:grid-cols-2 gap-8"><div class="step-card p-6"><h4 class="text-xl font-semibold mb-4">1.1 安裝工具</h4><p class="mb-4 text-gray-600"><span class="keyword"data-keyword-id="git-filter-repo">git-filter-repo</span> 是由 Python 3 開發的工具，請先確保您的環境已安裝 Python 3。然後，使用 pip 進行安裝。<div class="code-block p-4"><pre><code>pip install git-filter-repo</code></pre><button class="copy-button"onclick="copyCode(this)">複製</button></div><p class="mt-3 text-sm text-gray-500">提示：`git-filter-repo` 是 Git 官方推薦用來取代舊有 `git filter-branch` 和 BFG 等工具的現代化選擇。</div><div class="step-card p-6"><h4 class="text-xl font-semibold mb-4">1.2 建立全新的本地副本</h4><p class="mb-4 text-gray-600">為了避免本地端舊有的<span class="keyword"data-keyword-id="branch">分支</span>、快取或未追蹤的檔案干擾清理過程，強烈建議在一個全新的資料夾中，重新<span class="keyword"data-keyword-id="clone">clone</span>一份<span class="keyword"data-keyword-id="repository">儲存庫</span>來進行操作。<div class="code-block p-4"><pre><code>git clone --mirror [GIT_SERVER]:YOUR-ORG/YOUR-REPO.git
cd YOUR-REPO.git</code></pre><button class="copy-button"onclick="copyCode(this)">複製</button></div><p class="mt-3 text-sm text-gray-500">使用 <span class="keyword"data-keyword-id="--mirror">--mirror</span> 參數可以確保所有遠端參考（包括分支、<span class="keyword"data-keyword-id="tag">標籤</span>等）都被完整複製下來。</div></div><div class="step-card p-6 mt-8"><h4 class="text-xl font-semibold mb-4">1.3 團隊協作準備工作 (互動式清單)</h4><p class="mb-4 text-gray-600">在開始清理作業前，請務必完成以下協調，並勾選確認。<div class="space-y-3"><label class="checklist-item"><input type="checkbox"onclick="toggleChecklistItem(this)"> <span class="custom-checkbox"><svg class="custom-checkbox-tick"xmlns="http://www.w3.org/2000/svg"viewBox="0 0 20 20"fill="currentColor"color="white"><path fill-rule="evenodd"d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"clip-rule="evenodd"/></svg> </span>通知所有團隊成員，在清理完成前，<strong class="mx-1 text-red-600">嚴格禁止</strong>對此儲存庫進行任何 <span class="keyword"data-keyword-id="commit">commit</span> 或 <span class="keyword"data-keyword-id="push">push</span> 操作。</label> <label class="checklist-item"><input type="checkbox"onclick="toggleChecklistItem(this)"> <span class="custom-checkbox"><svg class="custom-checkbox-tick"xmlns="http://www.w3.org/2000/svg"viewBox="0 0 20 20"fill="currentColor"color="white"><path fill-rule="evenodd"d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"clip-rule="evenodd"/></svg> </span>請所有團隊成員將他們正在進行中、尚未 commit 的修改使用 <span class="keyword"data-keyword-id="git stash">git stash</span> 指令暫存起來。</label> <label class="checklist-item"><input type="checkbox"onclick="toggleChecklistItem(this)"> <span class="custom-checkbox"><svg class="custom-checkbox-tick"xmlns="http://www.w3.org/2000/svg"viewBox="0 0 20 20"fill="currentColor"color="white"><path fill-rule="evenodd"d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"clip-rule="evenodd"/></svg> </span>確認您已在一個全新的、乾淨的目錄中操作，避免任何干擾。</label></div></div></section><section id="execution"class="mb-16 scroll-mt-24"><h3 class="text-2xl font-bold mb-6 border-l-4 border-amber-500 pl-4">第二步：執行清理作業</h3><p class="mb-8 text-gray-700">準備工作就緒後，就可以開始執行清除敏感資訊的流程。核心步驟是建立一個「替換規則」檔案，然後執行 `git-filter-repo` 指令。<div class="step-card p-6"><h4 class="text-xl font-semibold mb-4">2.1 建立「替換規則」檔案</h4><p class="mb-4 text-gray-600">在儲存庫<strong class="text-red-600 mx-1">以外</strong>的地方，建立一個純文字檔，例如 `secrets.txt`。在此檔案中，定義要如何替換找到的敏感資訊。格式為 `舊的敏感資訊==>新的取代內容`。每一行代表一條替換規則。<div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6"><div><h5 class="font-semibold text-gray-800">策略一：保留標記</h5><p class="text-sm text-gray-500 mb-2">將敏感字串替換成一個有意義的標示，讓開發者知道這裡曾有密鑰已被移除。<div class="code-block p-4"><pre><code>aBcDeFgHiJkLMnOp==>SECRET_REMOVED
ghIjkLmnOpQrStUv==>API_KEY_REMOVED</code></pre><button class="copy-button"onclick="copyCode(this)">複製</button></div></div><div><h5 class="font-semibold text-gray-800">策略二：完全移除</h5><p class="text-sm text-gray-500 mb-2">將敏感字串直接替換成空字串，讓它從程式碼中徹底消失。<div class="code-block p-4"><pre><code>aBcDeFgHiJkLMnOp==>
ghIjkLmnOpQrStUv==></code></pre><button class="copy-button"onclick="copyCode(this)">複製</button></div></div></div><p class="mt-4 text-sm text-gray-500">提示：可以使用如 <a href="https://github.com/GitGuardian/ggshield"target="_blank"class="text-amber-600 hover:underline">GGShield</a> 等工具掃描整個儲存庫，找出所有外洩的 Token 或密鑰，以建立完整的規則檔案。</div><div class="step-card p-6 mt-8"><h4 class="text-xl font-semibold mb-4">2.2 執行 git-filter-repo 指令</h4><p class="mb-4 text-gray-600">切換到你新 clone 的鏡像儲存庫資料夾路徑下 (`YOUR-REPO.git`)，執行以下指令。請將 `[替換規則檔案的路徑]` 替換成你上一步建立的 `secrets.txt` 的實際路徑。<div class="code-block p-4"><pre><code>git filter-repo --replace-text [替換規則檔案的路徑]</code></pre><button class="copy-button"onclick="copyCode(this)">複製</button></div><p class="mt-3 text-sm text-gray-500">指令執行後，工具會快速掃描並重寫所有 <span class="keyword"data-keyword-id="commit">commit</span>，將符合規則的敏感資訊替換掉。它會自動處理備份，比舊工具有更高的安全性。</div></section><section id="finalize"class="mb-16 scroll-mt-24"><h3 class="text-2xl font-bold mb-6 border-l-4 border-amber-500 pl-4">第三步：完成與推送</h3><p class="mb-8 text-gray-700">本地歷史重寫完成後，最後一步就是將這個全新的、乾淨的歷史強制推送到遠端儲存庫，並處理殘留的風險。<div class="mt-8 p-6 border-l-4 border-red-500 bg-red-50 rounded-r-lg"><div class="flex"><div class="flex-shrink-0"><svg class="h-6 w-6 text-red-600"xmlns="http://www.w3.org/2000/svg"viewBox="0 0 20 20"fill="currentColor"aria-hidden="true"><path fill-rule="evenodd"d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.21 3.03-1.742 3.03H4.42c-1.532 0-2.492-1.696-1.742-3.03l5.58-9.92zM10 13a1 1 0 110-2 1 1 0 010 2zm-1-8a1 1 0 00-1 1v3a1 1 0 102 0V6a1 1 0 00-1-1z"clip-rule="evenodd"/></svg></div><div class="ml-3"><h4 class="text-xl font-semibold text-red-800">3.1 強制推送到遠端</h4><p class="mt-2 text-red-700"><strong>警告：</strong>這是一個<strong class="font-extrabold">破壞性操作</strong>。由於整個 Git 歷史已被重寫，必須使用「<span class="keyword"data-keyword-id="force push">強制推送 (force push)</span>」才能更新遠端的儲存庫。這會永久覆蓋遠端的歷史。請務必確認本地修改無誤後再執行。</div></div><p class="mt-6 text-gray-700 font-semibold">將乾淨的儲存庫推送到主儲存庫<div class="code-block p-4 mt-2"><pre><code>git remote add origin [GIT_SERVER]:YOUR-ORG/YOUR-REPO.git
git push --force --all origin
git push --force --tags origin</code></pre><button class="copy-button"onclick="copyCode(this)">複製</button></div></div><div class="step-card p-6 mt-8"><h4 class="text-xl font-semibold mb-4">3.2 處理 Forks 與後端殘留</h4><p class="mb-4 text-gray-600">強制推送主儲存庫後，還需要處理潛在的副本和伺服器殘留：<ul class="list-disc list-inside space-y-3 text-gray-700"><li><strong>清理 Forks：</strong> 聯絡所有 `Fork` 的擁有者，請他們執行同樣的歷史重寫流程，或是直接刪除並重新 `Fork` 乾淨的儲存庫。這是防止舊歷史被意外合併回來的關鍵。<li><strong>請求後端垃圾回收 (可選但建議)：</strong> 聯絡您的 Git 服務商 (如 GitHub Support)，提出「敏感資料刪除請求」。提供您的儲存庫 URL 和相關 commit SHA，並說明您已完成歷史重寫，請求他們手動觸發伺服器端的<span class="keyword"data-keyword-id="git gc">垃圾回收</span>，以盡快清除<span class="keyword"data-keyword-id="dangling commit">懸空提交</span>。</ul></div></section><section id="prevention"class="scroll-mt-24"><h3 class="text-2xl font-bold mb-6 border-l-4 border-amber-500 pl-4">第四步：後續防範</h3><p class="mb-8 text-gray-700">恭喜！您已完成所有必要的清理步驟。最後，請完成後續協調並建立防護機制，避免未來再犯。<div class="grid grid-cols-1 md:grid-cols-2 gap-8"><div class="step-card p-6"><h4 class="text-xl font-semibold mb-4">4.1 通知團隊並重新 Clone</h4><p class="mb-4 text-gray-600">這是至關重要的一步。由於遠端歷史已被重寫，所有團隊成員都<strong class="text-red-600">必須</strong>：<ul class="list-disc list-inside space-y-2 text-gray-700"><li><strong>刪除</strong>他們各自電腦上的舊儲存庫副本。<li>重新 `git clone` 一份最新的版本來繼續開發工作。<li>若之前有使用 `git stash` 暫存工作，現在可以在新的副本中用 `git stash pop` 來還原。</ul></div><div class="step-card p-6"><h4 class="text-xl font-semibold mb-4">4.2 建立自動化防護</h4><p class="mb-4 text-gray-600">為了避免未來再次發生同樣的錯誤，強烈建議在團隊的工作流程中導入自動化掃描機制：<ul class="list-disc list-inside space-y-2 text-gray-700"><li><strong>啟用平台防護：</strong> 在 GitHub/GitLab 等平台上啟用 <span class="font-semibold">Secret Scanning</span> 和 <span class="font-semibold">Push Protection</span> 功能。<li><strong>導入 <span class="keyword"data-keyword-id="pre-commit hook">Pre-commit Hook</span>：</strong> 在開發者本地端就攔截包含敏感資訊的提交。<li><strong>主分支保護：</strong> 設定分支保護規則，禁止對主要分支進行 `force push`。</ul></div></div></section><section id="security-warning"class="mt-16 scroll-mt-24 p-6 border-l-4 border-amber-500 bg-amber-50 rounded-r-lg"><div class="flex"><div class="flex-shrink-0"><svg class="h-6 w-6 text-amber-600"xmlns="http://www.w3.org/2000/svg"viewBox="0 0 20 20"fill="currentColor"aria-hidden="true"><path fill-rule="evenodd"d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.21 3.03-1.742 3.03H4.42c-1.532 0-2.492-1.696-1.742-3.03l5.58-9.92zM10 13a1 1 0 110-2 1 1 0 010 2zm-1-8a1 1 0 00-1 1v3a1 1 0 102 0V6a1 1 0 00-1-1z"clip-rule="evenodd"/></svg></div><div class="ml-3"><h3 class="text-xl font-semibold text-amber-800">補充說明：為何 Force Push 並不足夠？Git 的記憶比你想像的更長久</h3><div class="mt-2 text-amber-700 space-y-4"><p>許多人認為 `git push --force` 可以「抹掉」錯誤的提交，但這是一個危險的誤解。Git 的設計使得被移除的提交並不會立即消失，它們會變成<span class="keyword"data-keyword-id="dangling commit">「懸空提交」(Dangling Commit)</span>，在伺服器（如 GitHub）上殘留數週甚至更久，等待<span class="keyword"data-keyword-id="git gc">垃圾回收 (Garbage Collection)</span> 機制清理。<p>在它們被徹底清除前，這些敏感資料仍可能透過以下途徑被存取：<ul class="list-disc list-inside space-y-2"><li><strong>分支 (Forks)：</strong> 如果有人在您強制推送前 <span class="keyword"data-keyword-id="fork">Fork</span> 了您的儲存庫，舊的提交歷史會永久保存在他的副本中。<li><strong>直接網址：</strong> 只要知道提交的 <span class="keyword"data-keyword-id="sha-1">SHA-1</span> 雜湊值，任何人都可以透過 `https://github.com/&lt;user&gt;/&lt;repo&gt;/commit/&lt;hash&gt;` 的網址直接存取該次提交的內容。<li><strong>公開事件紀錄：</strong> 像 <span class="keyword"data-keyword-id="gh archive">GH Archive</span> 這類服務會公開蒐集 GitHub 的事件資料，其中就包含 `PushEvent` 的提交雜湊值。即使您的儲存庫已完成垃圾回收，這些事件紀錄依然存在。</ul><p class="font-bold text-lg p-3 bg-amber-100 rounded-md">安全第一原則：先撤銷憑證，再清理歷史。一旦秘密被推送，就必須假設它已完全外洩。清理歷史只是補救措施，無法取代汰換憑證的必要性。</div></div></div></section></main><footer class="bg-gray-800 text-gray-300 mt-16"><div class="container mx-auto py-6 px-4 sm:px-6 lg:px-8 text-center"><p>本指南由 <a href="https://wellstsai.com"target="_blank"rel="noopener noreferrer"class="text-amber-400 hover:text-amber-300 transition-colors duration-300 underline">wellstsai.com</a> 產生</div></footer></div><div id="keyword-modal"class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden"><div id="modal-overlay"class="modal-overlay fixed inset-0 bg-black/30 backdrop-blur-sm opacity-0"></div><div id="modal-container"class="modal-container bg-white/70 backdrop-blur-xl border border-white/30 rounded-2xl shadow-2xl w-full max-w-lg m-4 opacity-0 scale-95 transform"><div class="p-6"><div class="flex items-center justify-between pb-3 border-b border-gray-900/10"><h3 id="modal-title"class="text-xl font-bold text-gray-800"></h3><button id="modal-close-btn"class="p-1 rounded-full text-gray-500 hover:bg-gray-200 hover:text-gray-800 transition-colors"><svg xmlns="http://www.w3.org/2000/svg"class="h-6 w-6"fill="none"viewBox="0 0 24 24"stroke="currentColor"><path stroke-linecap="round"stroke-linejoin="round"stroke-width="2"d="M6 18L18 6M6 6l12 12"/></svg></button></div><div id="modal-content"class="mt-4 text-base text-gray-700 leading-relaxed"></div></div></div></div><script>const keywordDefinitions={"git-filter-repo":{title:"git-filter-repo",content:"一個用於重寫 Git 儲存庫歷史的強大腳本工具。它比舊有的 `git filter-branch` 更快、更安全，是 Git 官方目前推薦的歷史改寫工具，特別適用於清除敏感資料、移除大檔案等場景。"},"dangling commit":{title:"Dangling Commit (懸空提交)",content:"一個在 Git 儲存庫中存在，但無法從任何分支或標籤追溯到的提交物件。當你使用 `git reset` 或 `force push` 覆蓋歷史時，舊的提交就會變成懸空狀態。它們並未被立即刪除，而是在等待 Git 的垃圾回收機制來清理。"},"git gc":{title:"git gc (垃圾回收)",content:"Git 的內建維護指令，全名為 Garbage Collection。它會清理儲存庫中不再需要的物件（如懸空提交），並將多個鬆散的物件壓縮成更高效的格式以節省空間。在伺服器端，這個過程通常是自動且定期執行的。"},fork:{title:"Fork (分支/分叉)",content:"在 GitHub 等平台上，`Fork` 是指將某個儲存庫完整地複製一份到您自己的帳號下。這份副本包含了完整的歷史紀錄，讓您可以自由地進行修改而不會影響到原始專案。這也意味著，如果原始專案重寫了歷史，您的 `Fork` 版本若未同步，仍會保留著舊的、包含敏感資訊的歷史。"},"sha-1":{title:"SHA-1 (雜湊值)",content:"Git 使用 SHA-1 演算法為每一個物件（包括提交、樹物件、檔案內容）產生一個唯一的 40 字元長的十六進位雜湊值。這個值就像是該物件的「指紋」或身分證號，可以用來精確地引用歷史中的任何一個提交。"},"gh archive":{title:"GH Archive",content:"一個公開的專案，它會記錄並存檔所有在 GitHub 上發生的公開事件（如程式碼推送、建立議題、發布 Pull Request 等）。由於它會記錄 `PushEvent`，因此即使原始儲存庫的歷史被修改，提交的 SHA-1 雜湊值也可能已經被存檔在這裡，成為追溯敏感資訊的管道之一。"},"ci/cd":{title:"CI/CD",content:"持續整合 (Continuous Integration) 與持續部署/交付 (Continuous Deployment/Delivery) 的縮寫。這是一套軟體開發實踐，旨在透過自動化建置、測試和部署流程，來加速和簡化軟體發布的過程。"},commit:{title:"Commit (提交)",content:"Git 中的基本單位，代表著對儲存庫在某個時間點的「快照」。每一次 `commit` 都會儲存您當時所做的所有變更，並附帶一個唯一的 ID (hash)，從而構成了專案的完整歷史紀錄。"},push:{title:"Push (推送)",content:"將您本地儲存庫中的 `commit` 上傳到遠端儲存庫（如 GitHub、GitLab）的指令。這是與團隊成員分享您程式碼變更的主要方式。"},"git stash":{title:"git stash (暫存)",content:"一個方便的指令，可以將您當前工作目錄中尚未 `commit` 的修改暫時儲存起來，讓您的工作區恢復到乾淨的狀態。這讓您可以快速切換分支處理緊急任務，之後再回來恢復之前的工作進度。"},clone:{title:"Clone (克隆)",content:"從遠端儲存庫建立一個完整的本地副本的過程。這個副本包含了遠端儲存庫的所有檔案、分支以及完整的提交歷史。"},"force push":{title:"Force Push (強制推送)",content:"`git push --force` 的簡稱。這是一個具有破壞性的指令，它會強制用您本地的歷史紀錄覆蓋遠端儲存庫的歷史紀錄。<strong>應極度謹慎使用</strong>，因為它可能導致團隊成員的 `commit` 遺失。在本指南的場景中，因為我們有意重寫整個歷史，所以必須使用它。"},"pre-commit hook":{title:"Pre-commit Hook (提交前掛鉤)",content:"一種在您執行 `git commit` 指令後、但 Git 真正建立 `commit` 之前自動執行的腳本。開發者常用它來進行程式碼風格檢查、自動化測試或掃描程式碼中是否包含意外洩漏的密鑰，以確保提交的品質與安全性。"},repository:{title:"Repository (儲存庫)",content:'簡稱 "repo"，是 Git 用來管理專案的地方。它包含了專案的所有檔案、資料夾以及它們隨時間變化的完整歷史紀錄。'},branch:{title:"Branch (分支)",content:"一種輕量級的可移動指標，指向某個 `commit`。分支是 Git 的核心功能之一，它允許開發者在不影響主要程式碼（通常是 `main` 分支）的情況下，獨立開發新功能或修復錯誤。"},tag:{title:"Tag (標籤)",content:"用於標記儲存庫歷史中某個特定 `commit` 的指標，通常用來標示重要的發布版本（例如 `v1.0.0`）。與分支不同，標籤一旦設定後通常不會再移動。"},"--mirror":{title:"--mirror (鏡像選項)",content:"`git clone` 的一個選項，它會建立一個「裸儲存庫 (bare repository)」的完整副本。這個副本包含了所有遠端的參考資料（如分支、標籤），是一個完美的備份，常用於儲存庫遷移或像本指南一樣需要對整個歷史進行操作的場景。"}};function copyCode(t){const e=t.parentElement.querySelector("pre").innerText;navigator.clipboard.writeText(e).then(()=>{t.innerText="已複製!",setTimeout(()=>{t.innerText="複製"},2e3)}).catch(t=>{console.error("複製失敗: ",t)})}function toggleChecklistItem(t){const e=t.closest(".checklist-item");t.checked?e.classList.add("completed"):e.classList.remove("completed")}document.addEventListener("DOMContentLoaded",()=>{const t=document.getElementById("keyword-modal"),e=document.getElementById("modal-overlay"),o=document.getElementById("modal-container"),n=document.getElementById("modal-close-btn"),i=document.getElementById("modal-title"),c=document.getElementById("modal-content"),r=document.body,s=()=>{e.classList.add("opacity-0"),o.classList.add("opacity-0","scale-95");const n=()=>{t.classList.add("hidden"),r.classList.remove("modal-open","overflow-hidden"),o.removeEventListener("transitionend",n)};o.addEventListener("transitionend",n)};document.querySelectorAll(".keyword").forEach(n=>{n.addEventListener("click",n=>{n.stopPropagation();(n=>{const s=keywordDefinitions[n];s&&(i.textContent=s.title,c.innerHTML=s.content,r.classList.add("modal-open","overflow-hidden"),t.classList.remove("hidden"),e.offsetWidth,o.offsetWidth,e.classList.remove("opacity-0"),o.classList.remove("opacity-0","scale-95"))})(n.currentTarget.dataset.keywordId)})}),e.addEventListener("click",s),n.addEventListener("click",s),document.addEventListener("keydown",e=>{"Escape"!==e.key||t.classList.contains("hidden")||s()});const l=document.querySelectorAll("main section"),a=document.querySelectorAll("header nav a"),d=new IntersectionObserver(t=>{t.forEach(t=>{t.isIntersecting&&a.forEach(e=>{e.classList.toggle("active",e.getAttribute("href").substring(1)===t.target.id)})})},{rootMargin:"-30% 0px -70% 0px"});l.forEach(t=>{d.observe(t)})})</script>