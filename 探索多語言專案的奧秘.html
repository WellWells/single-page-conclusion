<!doctypehtml><html lang="zh-Hant"><meta name="twitter:image"content="https://wellstsai.com/single-page-conclusion/%E6%8E%A2%E7%B4%A2%E5%A4%9A%E8%AA%9E%E8%A8%80%E5%B0%88%E6%A1%88%E7%9A%84%E5%A5%A7%E7%A7%98.png"><meta name="twitter:description"content="揭開多語言專案的底層秘辛：從編譯流程、連結機制到 ABI 溝通規則，並以 C、Rust、組合語言混合實戰與最佳實務說明何時採用多語言以達效能與安全兼顧。"><meta name="twitter:title"content="探索多語言專案的奧秘"><meta name="twitter:card"content="summary_large_image"><meta property="og:type"content="article"><meta property="og:site_name"content="WellWells"><meta property="og:image"content="https://wellstsai.com/single-page-conclusion/%E6%8E%A2%E7%B4%A2%E5%A4%9A%E8%AA%9E%E8%A8%80%E5%B0%88%E6%A1%88%E7%9A%84%E5%A5%A7%E7%A7%98.png"><meta property="og:url"content="https://wellstsai.com/single-page-conclusion/%E6%8E%A2%E7%B4%A2%E5%A4%9A%E8%AA%9E%E8%A8%80%E5%B0%88%E6%A1%88%E7%9A%84%E5%A5%A7%E7%A7%98.html"><meta property="og:description"content="揭開多語言專案的底層秘辛：從編譯流程、連結機制到 ABI 溝通規則，並以 C、Rust、組合語言混合實戰與最佳實務說明何時採用多語言以達效能與安全兼顧。"><meta property="og:title"content="探索多語言專案的奧秘"><meta name="description"content="揭開多語言專案的底層秘辛：從編譯流程、連結機制到 ABI 溝通規則，並以 C、Rust、組合語言混合實戰與最佳實務說明何時採用多語言以達效能與安全兼顧。"><meta charset="UTF-8"><meta name="viewport"content="width=device-width,initial-scale=1"><title>探索多語言專案的奧秘</title><script src="https://cdn.tailwindcss.com"></script><script src="https://cdn.jsdelivr.net/npm/chart.js"></script><link rel="preconnect"href="https://fonts.googleapis.com"><link rel="preconnect"href="https://fonts.gstatic.com"crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap"rel="stylesheet"><style>body{font-family:'Noto Sans TC',sans-serif;background-color:#f8f7f4;color:#4a4a4a}.bg-primary{background-color:#f8f7f4}.bg-secondary{background-color:#fff}.text-primary{color:#4a4a4a}.text-secondary{color:#7a7a7a}.accent-color{color:#4a90e2}.accent-bg{background-color:#4a90e2}.accent-border{border-color:#4a90e2}.section-title{font-size:2rem;font-weight:700;margin-bottom:1rem;text-align:center}.section-subtitle{font-size:1.125rem;color:#7a7a7a;margin-bottom:2.5rem;text-align:center;max-width:600px;margin-left:auto;margin-right:auto}.nav-link{transition:color .3s}.nav-link.active,.nav-link:hover{color:#4a90e2}.pipeline-step>div{transition:all .3s ease}.pipeline-step.active>div{transform:translateY(-5px);background-color:#4a90e2;color:#fff;box-shadow:0 10px 15px -3px rgb(0 0 0 / .1),0 4px 6px -4px rgb(0 0 0 / .1)}.pipeline-step.active .step-number{background-color:#fff;color:#4a90e2}.code-block{background-color:#2d2d2d;color:#f2f2f2;padding:1rem;border-radius:.5rem;font-family:monospace;white-space:pre-wrap;font-size:.875rem;line-height:1.5;overflow-x:auto}.abi-animation-box{border:2px dashed #d1d5db;min-height:200px;padding:1rem}.register{border:2px solid #9ca3af;padding:.5rem 1rem;margin:.25rem;border-radius:.25rem;transition:all .5s ease-in-out,transform .3s ease;min-width:110px;text-align:center;background-color:#f3f4f6}.arrow{transition:all .5s ease-in-out;opacity:0;transform:scale(.5)}.animate .arrow{opacity:1;transform:scale(1)}.animate .register-source{background-color:#a7f3d0;border-color:#10b981;transform:scale(1.05)}.animate .register-dest{background-color:#a7f3d0;border-color:#10b981;transform:scale(1.05)}.animate .register-dest.mismatch{background-color:#fecaca;border-color:#ef4444}.chart-container{position:relative;width:100%;max-width:600px;margin-left:auto;margin-right:auto;height:300px;max-height:400px}.keyword{color:#4f46e5;font-weight:600;cursor:pointer;position:relative;transition:transform .2s ease-in-out;display:inline-block}.keyword:hover{transform:scale(1.05);color:#312e81}.keyword::after{content:'';position:absolute;width:100%;height:2px;bottom:-2px;left:0;background:linear-gradient(to right,#6366f1,#8b5cf6);transform:scaleX(0);transform-origin:bottom right;transition:transform .25s ease-out}.keyword:hover::after{transform:scaleX(1);transform-origin:bottom left}#keyword-modal.hidden{display:none}#keyword-modal{display:flex}#modal-backdrop{transition:opacity .3s ease;opacity:0}#modal-panel{transition:opacity .3s ease,transform .3s ease;opacity:0;transform:scale(.95)}#keyword-modal.visible #modal-backdrop{opacity:1}#keyword-modal.visible #modal-panel{opacity:1;transform:scale(1)}@media (min-width:768px){.chart-container{height:350px}}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-JKC4KZLT26"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JKC4KZLT26")</script><body class="bg-primary text-primary"><header id="header"class="bg-secondary/80 backdrop-blur-md sticky top-0 z-40 shadow-sm"><nav class="container mx-auto px-6 py-3 flex justify-between items-center"><h1 class="text-xl font-bold accent-color">多語言專案的奧秘</h1><div class="hidden md:flex space-x-8"><a href="#intro"class="nav-link">介紹</a> <a href="#compilation"class="nav-link">編譯流程</a> <a href="#linking"class="nav-link">連結機制</a> <a href="#mixing"class="nav-link">混合實戰</a> <a href="#abi"class="nav-link">溝通規則</a> <a href="#reasons"class="nav-link">為何要用</a></div><div class="md:hidden"><select id="mobile-nav"class="bg-white border border-gray-300 rounded-md p-1"><option value="#intro">介紹<option value="#compilation">編譯流程<option value="#linking">連結機制<option value="#mixing">混合實戰<option value="#abi">溝通規則<option value="#reasons">為何要用</select></div></nav></header><main class="container mx-auto px-6 py-12"><section id="intro"class="text-center min-h-[60vh] flex items-center justify-center flex-col"><h2 class="text-4xl md:text-5xl font-bold mb-4">為何有些專案要用多種程式語言？</h2><p class="text-lg md:text-xl text-secondary max-w-3xl">從網站開發到作業系統核心，許多軟體都巧妙地融合了多種語言。有些情況很直觀，例如網頁前後端分離；但有些情況則更為深入，多種語言被編譯成單一的執行檔。本頁將帶您探索這背後的底層秘密。</section><section id="compilation"class="py-16"><h3 class="section-title">編譯的真相：不只是個黑盒子</h3><p class="section-subtitle">我們常說「編譯器將原始碼變成執行檔」，但這其實是一個精細的多步驟過程。了解這個過程，是理解多語言混合的關鍵第一步。點擊下方各階段，看看一段簡單的C語言程式碼是如何一步步轉換的。<div class="bg-secondary p-8 rounded-xl shadow-lg"><div id="pipeline-container"class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8"><div class="pipeline-step"data-step="1"><div class="flex items-center justify-center p-4 rounded-lg bg-gray-100 flex-col cursor-pointer"><span class="step-number w-8 h-8 rounded-full bg-blue-500 text-white flex items-center justify-center font-bold mb-2">1</span> <span class="font-semibold text-center">前置處理</span></div></div><div class="pipeline-step"data-step="2"><div class="flex items-center justify-center p-4 rounded-lg bg-gray-100 flex-col cursor-pointer"><span class="step-number w-8 h-8 rounded-full bg-blue-500 text-white flex items-center justify-center font-bold mb-2">2</span> <span class="font-semibold text-center">編譯</span></div></div><div class="pipeline-step"data-step="3"><div class="flex items-center justify-center p-4 rounded-lg bg-gray-100 flex-col cursor-pointer"><span class="step-number w-8 h-8 rounded-full bg-blue-500 text-white flex items-center justify-center font-bold mb-2">3</span> <span class="font-semibold text-center">組譯</span></div></div><div class="pipeline-step"data-step="4"><div class="flex items-center justify-center p-4 rounded-lg bg-gray-100 flex-col cursor-pointer"><span class="step-number w-8 h-8 rounded-full bg-blue-500 text-white flex items-center justify-center font-bold mb-2">4</span> <span class="font-semibold text-center">連結</span></div></div></div><div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-start"><div><h4 class="font-bold text-lg mb-2">輸出結果：</h4><div class="code-block"id="code-display"></div></div><div><h4 class="font-bold text-lg mb-2">階段說明：</h4><p class="text-secondary"id="explanation-display"></div></div></div></section><section id="linking"class="py-16"><h3 class="section-title">連結的魔法：靜態 vs. 動態</h3><p class="section-subtitle">「<span class="keyword"data-keyword-id="linking">連結</span>」是編譯流程的最後一步，它負責將所有需要的程式碼片段組合成一個完整的執行檔。主要有兩種方式，它們在效率和彈性上有著截然不同的取捨。<div class="text-center mb-8"><div class="inline-flex bg-gray-200 rounded-lg p-1"><button id="static-btn"class="px-6 py-2 rounded-md font-semibold text-white accent-bg">靜態連結</button> <button id="dynamic-btn"class="px-6 py-2 rounded-md font-semibold text-gray-600">動態連結</button></div></div><div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center"><div id="linking-info"><h4 id="linking-title"class="text-2xl font-bold mb-2"></h4><p id="linking-desc"class="text-secondary mb-6"><ul class="space-y-4"><li id="linking-pro"class="flex items-start text-lg"><span class="text-green-500 mr-3 mt-1 text-xl">✔</span><div></div><li id="linking-con"class="flex items-start text-lg"><span class="text-red-500 mr-3 mt-1 text-xl">✘</span><div></div></ul></div><div class="chart-container"><canvas id="linkingChart"></canvas></div></div></section><section id="mixing"class="py-16"><h3 class="section-title">混合語言實戰</h3><p class="section-subtitle">正因為編譯流程是模組化的，且最終都由「連結器」來組合，我們才有可能混合不同語言。只要每種語言都能被編譯成連結器看得懂的「<span class="keyword"data-keyword-id="object-file">目的檔</span>」，它們就能合作。<div class="grid grid-cols-1 md:grid-cols-2 gap-8"><div class="bg-secondary p-6 rounded-xl shadow-lg"><h4 class="text-xl font-bold mb-2">範例一：C + <span class="keyword"data-keyword-id="assembly">組合語言</span></h4><p class="text-secondary mb-4">這是最常見的組合。當對效能有極致要求時，開發者會用<span class="keyword"data-keyword-id="assembly">組合語言</span>手寫最核心的計算部分，然後由C語言來呼叫它，處理其他邏輯。<div class="space-y-2"><div class="code-block text-sm"><span class="text-gray-400">// main.c</span> <span class="text-purple-400">extern int</span> <span class="text-yellow-300">calculate_primes</span>(<span class="text-purple-400">int</span> max); printf(<span class="text-green-300">"Primes: %d\n"</span>, calculate_primes(1000));</div><div class="text-center font-bold">+</div><div class="code-block text-sm"><span class="text-gray-400">; primes.asm</span> <span class="text-blue-400">global</span> calculate_primes calculate_primes: &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-gray-400">; ... 高效能的組合語言實作 ...</span> &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-blue-400">ret</span></div><div class="text-center text-2xl">↓</div><div class="bg-blue-100 text-blue-800 p-3 rounded-md text-center font-semibold">🔗 連結器 (Linker) → 單一執行檔</div></div></div><div class="bg-secondary p-6 rounded-xl shadow-lg"><h4 class="text-xl font-bold mb-2">範例二：C + Rust</h4><p class="text-secondary mb-4">高階語言之間也可以混合。例如，我們可以利用Rust的記憶體安全特性來編寫一個函式庫，然後在現有的C專案中呼叫它，兼顧安全與效能。<div class="space-y-2"><div class="code-block text-sm"><span class="text-gray-400">// main.c</span> <span class="text-purple-400">extern void</span> <span class="text-yellow-300">process_data_from_rust</span>(); process_data_from_rust();</div><div class="text-center font-bold">+</div><div class="code-block text-sm"><span class="text-gray-400">// lib.rs</span> <span class="text-gray-400">#[no_mangle]</span> <span class="text-blue-400">pub extern "C" fn</span> <span class="text-yellow-300">process_data_from_rust</span>() { &nbsp;&nbsp;&nbsp;&nbsp;<span class="text-gray-400">// ... Rust 的安全程式碼 ...</span> }</div><div class="text-center text-2xl">↓</div><div class="bg-green-100 text-green-800 p-3 rounded-md text-center font-semibold">🔗 連結器 (Linker) → 單一執行檔</div></div></div></div></section><section id="abi"class="py-16"><h3 class="section-title">溝通的規則：<span class="keyword"data-keyword-id="abi">應用程式二進位介面 (ABI)</span></h3><p class="section-subtitle">能連結在一起還不夠，不同語言編譯出來的機器碼還必須遵守相同的「溝通規則」，才能正確地呼叫彼此。這個規則就叫做 <span class="keyword"data-keyword-id="abi">ABI</span>，它定義了函式呼叫時參數如何傳遞、回傳值放哪裡等底層細節。<div class="grid grid-cols-1 md:grid-cols-2 gap-8"><div class="bg-secondary p-6 rounded-xl shadow-lg"><h4 class="text-xl font-bold mb-2 text-red-600">情境一：ABI 不匹配</h4><p class="text-secondary mb-4">語言A認為參數要放在<span class="keyword"data-keyword-id="register">暫存器</span>0和1，但語言B卻期望從<span class="keyword"data-keyword-id="register">暫存器</span>1和2讀取。這種誤會會導致程式執行錯誤，甚至崩潰。<div id="abi-mismatch-box"class="abi-animation-box flex flex-col items-center justify-center space-y-2"><div>語言A (呼叫方)</div><div class="flex"><div class="register register-source"id="mismatch-a-r0">R0: 參數1</div><div class="register register-source"id="mismatch-a-r1">R1: 參數2</div></div><div class="arrow text-3xl">⬇</div><div>語言B (被呼叫方)</div><div class="flex"><div class="register register-dest mismatch"id="mismatch-b-r1">R1: ???</div><div class="register register-dest mismatch"id="mismatch-b-r2">R2: ???</div></div></div><button id="animate-mismatch"class="mt-4 w-full accent-bg text-white font-semibold py-2 rounded-lg transition hover:bg-blue-600">播放動畫</button></div><div class="bg-secondary p-6 rounded-xl shadow-lg"><h4 class="text-xl font-bold mb-2 text-green-600">情境二：ABI 一致 (例如都遵守C ABI)</h4><p class="text-secondary mb-4">透過 `extern "C"` 等關鍵字，我們可以指示編譯器遵循一個共同的標準<span class="keyword"data-keyword-id="abi">ABI</span>。這樣，雙方就能正確無誤地溝通。<div id="abi-match-box"class="abi-animation-box flex flex-col items-center justify-center space-y-2"><div>語言A (呼叫方)</div><div class="flex"><div class="register register-source"id="match-a-r0">R0: 參數1</div><div class="register register-source"id="match-a-r1">R1: 參數2</div></div><div class="arrow text-3xl">⬇</div><div>語言B (被呼叫方)</div><div class="flex"><div class="register register-dest"id="match-b-r0">R0: ???</div><div class="register register-dest"id="match-b-r1">R1: ???</div></div></div><button id="animate-match"class="mt-4 w-full accent-bg text-white font-semibold py-2 rounded-lg transition hover:bg-blue-600">播放動畫</button></div></div></section><section id="reasons"class="py-16"><h3 class="section-title">那麼，為何要這麼做？</h3><p class="section-subtitle">混合多種語言雖然增加了複雜度，但在特定情境下能帶來巨大好處，這是一種工程上的權衡取捨。<div class="grid grid-cols-1 md:grid-cols-3 gap-8 text-center"><div class="bg-secondary p-6 rounded-xl shadow"><div class="text-4xl mb-4">🚀</div><h4 class="text-lg font-bold mb-2">極致的效能</h4><p class="text-secondary">用高階語言快速開發大部分功能，再將效能瓶頸部分用C或<span class="keyword"data-keyword-id="assembly">組合語言</span>改寫，達到兩全其美。</div><div class="bg-secondary p-6 rounded-xl shadow"><div class="text-4xl mb-4">📚</div><h4 class="text-lg font-bold mb-2">利用現有生態系</h4><p class="text-secondary">許多成熟、穩定、高效的函式庫都是用C寫的。新語言可透過 <span class="keyword"data-keyword-id="ffi">FFI</span> 直接呼叫這些函式庫，無需重造輪子。</div><div class="bg-secondary p-6 rounded-xl shadow"><div class="text-4xl mb-4">🛠️</div><h4 class="text-lg font-bold mb-2">使用最適合的工具</h4><p class="text-secondary">不同的語言有不同的專長。例如，用Python做數據分析，用C++做圖形渲染，並讓它們在同一個專案中協同工作。</div></div></section></main><div id="keyword-modal"class="fixed inset-0 z-50 items-center justify-center hidden"role="dialog"aria-modal="true"><div id="modal-backdrop"class="fixed inset-0 bg-black/30 backdrop-blur-sm"aria-hidden="true"></div><div id="modal-panel"class="relative z-10 bg-white/80 backdrop-blur-xl rounded-lg shadow-xl border border-white/20 p-6 m-4 max-w-lg w-full"><h3 id="modal-title"class="text-xl font-bold text-gray-900"></h3><p id="modal-content"class="mt-4 text-gray-700"></p><button id="modal-close-btn"class="absolute top-3 right-3 text-gray-500 hover:text-gray-900 text-2xl leading-none">&times;</button></div></div><footer class="bg-gray-800 text-gray-400 mt-12 py-6"><div class="container mx-auto px-6 text-center text-sm"><p class="mb-2"><a href="https://wellstsai.com"target="_blank"rel="noopener noreferrer"class="hover:text-white transition-colors">Generated by wellstsai.com</a><p>撰寫日期：<span id="generation-date"></span></div></footer><script>document.addEventListener("DOMContentLoaded",function(){const e={1:{title:"前置處理 (Preprocessing)",code:'// main.c\n#include <stdio.h>\n\n// 定義一個宏\n#define MESSAGE "Hello, World!"\n\nint main() {\n    /* 這是主函數 */\n    printf(MESSAGE);\n    return 0;\n}',explanation:'前置處理器會處理原始碼，進行諸如移除註解、展開宏定義 (#define)、以及將 #include 的標頭檔內容插入到程式碼中等操作。此階段的輸出仍然是 <span class="keyword" data-keyword-id="c-language">C語言</span> 程式碼。'},2:{title:"編譯 (Compilation)",code:"; 簡化的組合語言\nsection .data\n    message db 'Hello, World!', 0\n\nsection .text\n    global main\n    extern printf\n\nmain:\n    push    rbp\n    mov     rbp, rsp\n    mov     rdi, message\n    call    printf\n    xor     rax, rax\n    pop     rbp\n    ret",explanation:'真正的 <span class="keyword" data-keyword-id="compilation">編譯</span> 階段開始。編譯器會將前置處理過的C程式碼，翻譯成特定CPU架構的 <span class="keyword" data-keyword-id="assembly">組合語言</span>。組合語言是機器指令的人類可讀版本。'},3:{title:"組譯 (Assembly)",code:"01001000 01100101 01101100...\n(目的檔 - Object File)\n機器碼是CPU唯一能直接執行的二進位指令。組譯器(Assembler)會將組合語言翻譯成機器碼，並產生一個稱為「目的檔」(.o 或 .obj)的檔案。",explanation:'組譯器(Assembler)將 <span class="keyword" data-keyword-id="assembly">組合語言</span> 翻譯成純粹的0和1，也就是CPU能直接理解的機器碼。輸出的結果是一個「<span class="keyword" data-keyword-id="object-file">目的檔</span>」，它包含了這段程式碼的機器指令，但通常還不是一個完整的可執行檔。'},4:{title:"連結 (Linking)",code:"my_program.exe (或 ./my_program)\n(可執行檔 - Executable)\n連結器將你的目的檔，以及程式中用到的所有函式庫（例如C標準函式庫中的printf）中的相關目的檔，全部捆綁在一起，最終產生一個獨立的可執行檔。",explanation:'連結器(Linker)是最後的工匠。它將我們自己程式的 <span class="keyword" data-keyword-id="object-file">目的檔</span>，與所依賴的外部函式庫（例如C標準函式庫）中對應的程式碼結合起來，解決函式呼叫的位址問題，最終產生一個完整的、可以被作業系統執行的檔案。'}},t=document.querySelectorAll(".pipeline-step"),n=document.getElementById("code-display"),a=document.getElementById("explanation-display");function i(i){t.forEach(e=>e.classList.remove("active"));const o=document.querySelector(`.pipeline-step[data-step="${i}"]`);o&&(o.classList.add("active"),n.textContent=e[i].code,a.innerHTML=e[i].explanation,x(a))}t.forEach(e=>{e.addEventListener("click",()=>{i(e.dataset.step)})}),i(1);const o=document.getElementById("static-btn"),c=document.getElementById("dynamic-btn"),s=document.getElementById("linking-title"),d=document.getElementById("linking-desc"),l=document.querySelector("#linking-pro div"),r=document.querySelector("#linking-con div");let m;const g={static:{labels:["程式A","程式B","程式C","總大小"],datasets:[{label:"檔案大小 (MB)",data:[15,15,15,45],backgroundColor:"rgba(74, 144, 226, 0.6)"}]},dynamic:{labels:["程式A","程式B","程式C","共享函式庫","總大小"],datasets:[{label:"檔案大小 (MB)",data:[5,5,5,10,25],backgroundColor:"rgba(80, 227, 194, 0.6)"}]}};function y(e){"static"===e?(o.classList.add("accent-bg","text-white"),c.classList.remove("accent-bg","text-white"),s.innerHTML='<span class="keyword" data-keyword-id="static-linking">靜態連結</span> (Static Linking)',d.innerHTML="靜態連結會將所有需要的函式庫程式碼，完整地複製一份並嵌入到最終的執行檔中。這就像是為每本書都附上一本完整的字典。",l.innerHTML='<strong class="accent-color">優點:</strong> 執行檔自給自足，不依賴外部檔案，部署簡單。',r.innerHTML='<strong class="accent-color">缺點:</strong> 檔案體積龐大，多個程式會儲存多份相同的函式庫，浪費磁碟空間。'):(c.classList.add("accent-bg","text-white"),o.classList.remove("accent-bg","text-white"),s.innerHTML='<span class="keyword" data-keyword-id="dynamic-linking">動態連結</span> (Dynamic Linking)',d.innerHTML='動態連結只在執行檔中儲存一個指向「<span class="keyword" data-keyword-id="shared-library">共享函式庫</span>」的參考。作業系統會在程式執行時，才將需要的函式庫載入記憶體。這就像多本書共享圖書館裡的一本字典。',l.innerHTML='<strong class="accent-color">優點:</strong> 極大地節省磁碟空間與記憶體，更新函式庫也只需替換一個檔案。',r.innerHTML='<strong class="accent-color">缺點:</strong> 執行檔依賴外部檔案 (.dll, .so)，可能出現「缺少函式庫」的錯誤。'),function(e){const t=document.getElementById("linkingChart").getContext("2d");m&&m.destroy(),m=new Chart(t,{type:"bar",data:g[e],options:{responsive:!0,maintainAspectRatio:!1,scales:{y:{beginAtZero:!0,title:{display:!0,text:"磁碟空間佔用 (MB)"},max:50}},plugins:{legend:{display:!1}}}})}(e),x(document.getElementById("linking-info"))}function p(e,t){const n=document.getElementById(e);n.classList.remove("animate"),n.offsetWidth,n.classList.add("animate"),t&&(document.getElementById("match-b-r0").textContent="R0: 參數1",document.getElementById("match-b-r1").textContent="R1: 參數2"),setTimeout(()=>{n.classList.remove("animate"),t&&(document.getElementById("match-b-r0").textContent="R0: ???",document.getElementById("match-b-r1").textContent="R1: ???")},1500)}o.addEventListener("click",()=>y("static")),c.addEventListener("click",()=>y("dynamic")),y("static"),document.getElementById("animate-mismatch").addEventListener("click",()=>p("abi-mismatch-box",!1)),document.getElementById("animate-match").addEventListener("click",()=>p("abi-match-box",!0));const u=document.querySelectorAll(".nav-link"),b=document.querySelectorAll("main section");window.addEventListener("scroll",()=>{let e="";b.forEach(t=>{const n=t.offsetTop;pageYOffset>=n-70&&(e=t.getAttribute("id"))}),u.forEach(t=>{t.classList.remove("active"),t.getAttribute("href")===`#${e}`&&t.classList.add("active")})}),document.getElementById("mobile-nav").addEventListener("change",e=>{document.querySelector(e.target.value).scrollIntoView({behavior:"smooth"})}),document.getElementById("generation-date").textContent="2025/9/10";const k=document.getElementById("keyword-modal"),L=document.getElementById("modal-backdrop"),E=document.getElementById("modal-close-btn"),v=document.getElementById("modal-title"),f=document.getElementById("modal-content"),h={"c-language":{title:"C 語言",content:"一種通用且指令式的程式語言，支援結構化程式設計、詞法作用域與遞迴，並允許直接進行低階記憶體操作（如指標運算）。C 對後來多種語言（例如 C++、Java、C# 等）在語法與設計思想上有深遠影響。"},compilation:{title:"編譯 (Compilation)",content:"將人類可讀的原始碼轉換為電腦可執行的機器碼的過程。常見分為數個階段：預處理 (preprocessing)、編譯（產生組合語言或中間表示）、組譯（assembly，產生目的檔）與連結（linking）。這些步驟通常由編譯器、組譯器與連結器共同完成。"},assembly:{title:"組合語言 (Assembly Language)",content:"一種低階程式語言，使用助記符（mnemonics）對應特定的機器碼指令。組合語言與特定 CPU 架構高度相關，提供對硬體的直接控制，常用於需要精細效能或硬體存取的情況。"},linking:{title:"連結 (Linking)",content:"編譯流程的最後階段，由連結器（linker）將一或多個目的檔（object files）與所需函式庫的符號解析、重定位後合併成單一可執行檔或可載入模組。連結可發生為靜態或動態，並需處理符號解析與位址重定位。"},"object-file":{title:"目的檔 (Object File)",content:"由編譯器或組譯器產生的檔案，通常包含可重定位的機器碼、符號表、重定位資訊與資料區段。目的檔尚非完整可執行檔，需經連結器解析符號與重定位後才能產生最終的執行檔或庫。"},"static-linking":{title:"靜態連結 (Static Linking)",content:"一種連結方式，於連結階段將所需函式庫的程式碼直接複製到最終可執行檔中，產生可獨立執行的二進位檔。優點為部署簡單、執行時不依賴外部庫；缺點為檔案體積較大且更新庫需要重新編譯或重新連結。"},"dynamic-linking":{title:"動態連結 (Dynamic Linking)",content:"一種連結方式，於程式啟動或執行時由作業系統載入共享函式庫，而非在編譯時將程式碼複製到執行檔中。可節省磁碟空間並允許多個程式共用相同程式碼，但需處理版本相容性與符號可見性（例如 soname、版本號）。"},"shared-library":{title:"共享函式庫 (Shared Library)",content:"一類特殊的二進位檔，用於在執行時由多個程式共用程式碼與資料。常見副檔名包括 Windows 的 .dll、Linux 的 .so、macOS 的 .dylib。共享函式庫是實現動態連結的基礎。"},abi:{title:"應用程式二進位介面 (Application Binary Interface)",content:"定義程式模組之間在機器碼層級的介面，規範呼叫約定（參數與回傳值如何傳遞）、暫存器用途、資料型別大小與對齊、系統呼叫介面等底層細節。ABI 是跨語言或跨模組進行二進位互通的關鍵。"},register:{title:"暫存器 (Register)",content:"CPU 內部高速的暫存單元，用於暫時存放資料、運算結果與位址等。暫存器數量與型態由 CPU 架構決定。在多數 ABI/呼叫慣例中，部分函式參數與回傳值會透過暫存器傳遞以提升效能，但具體規則取決於所使用的呼叫慣例。"},ffi:{title:"外部函式介面 (Foreign Function Interface)",content:"一種機制，允許一種程式語言呼叫由另一種語言撰寫的函式或程式庫。實作上可能需要雙方遵循相同的 ABI，或透過封裝/轉換（marshalling）層來處理資料表示與記憶體管理差異。"}};function w(){k.classList.remove("visible"),setTimeout(()=>k.classList.add("hidden"),300),document.removeEventListener("keydown",C)}function C(e){"Escape"===e.key&&w()}function x(e){e.querySelectorAll(".keyword").forEach(e=>{e.addEventListener("click",e=>{e.stopPropagation();!function(e){const t=h[e];t&&(v.textContent=t.title,f.textContent=t.content,k.classList.remove("hidden"),setTimeout(()=>k.classList.add("visible"),10),document.addEventListener("keydown",C))}(e.currentTarget.dataset.keywordId)})})}x(document.body),L.addEventListener("click",w),E.addEventListener("click",w)})</script>