<!doctypehtml><html lang="zh-Hant"><meta name="twitter:image"content="https://wellstsai.com/single-page-conclusion/%E5%BE%9E%E9%8E%96%E5%8C%A0%E7%9A%84%E8%AC%8E%E9%A1%8C%E5%88%B0%E5%85%AC%E9%91%B0%E5%8A%A0%E5%AF%86.png"><meta name="twitter:description"content="從鎖匠謎題看「密鑰分發難題」。文章說明對稱加密的困境，以及單向函數（如質因數分解）如何促成非對稱加密與RSA演算法，奠定現代網路通訊安全。"><meta name="twitter:title"content="從鎖匠的謎題到公鑰加密"><meta name="twitter:card"content="summary_large_image"><meta property="og:type"content="article"><meta property="og:site_name"content="WellWells"><meta property="og:image"content="https://wellstsai.com/single-page-conclusion/%E5%BE%9E%E9%8E%96%E5%8C%A0%E7%9A%84%E8%AC%8E%E9%A1%8C%E5%88%B0%E5%85%AC%E9%91%B0%E5%8A%A0%E5%AF%86.png"><meta property="og:url"content="https://wellstsai.com/single-page-conclusion/%E5%BE%9E%E9%8E%96%E5%8C%A0%E7%9A%84%E8%AC%8E%E9%A1%8C%E5%88%B0%E5%85%AC%E9%91%B0%E5%8A%A0%E5%AF%86.html"><meta property="og:description"content="從鎖匠謎題看「密鑰分發難題」。文章說明對稱加密的困境，以及單向函數（如質因數分解）如何促成非對稱加密與RSA演算法，奠定現代網路通訊安全。"><meta property="og:title"content="從鎖匠的謎題到公鑰加密"><meta name="description"content="從鎖匠謎題看「密鑰分發難題」。文章說明對稱加密的困境，以及單向函數（如質因數分解）如何促成非對稱加密與RSA演算法，奠定現代網路通訊安全。"><meta charset="UTF-8"><meta name="viewport"content="width=device-width,initial-scale=1"><title>從鎖匠的謎題到公鑰加密</title><script src="https://cdn.tailwindcss.com"></script><link rel="preconnect"href="https://fonts.googleapis.com"><link rel="preconnect"href="https://fonts.gstatic.com"crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"rel="stylesheet"><style>body{font-family:Inter,'Noto Sans TC',sans-serif;scroll-behavior:smooth}.card{background-color:rgba(0,0,0,.3);border:1px solid rgb(51 65 85);border-radius:.5rem;box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05)}#animated-message{transition:transform 1.5s ease-in-out,opacity .5s ease-in-out;transform:translateX(0)}tbody tr:hover{background-color:rgb(30 41 59)}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-JKC4KZLT26"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JKC4KZLT26")</script><body class="bg-gradient-to-b from-gray-900 via-slate-900 to-black text-slate-300 antialiased"><header class="text-center py-16 md:py-24 px-4"><h1 class="text-4xl md:text-6xl font-bold mb-4"><span class="text-transparent bg-clip-text bg-gradient-to-r from-emerald-400 to-cyan-400">從鎖匠的謎題到公鑰加密</span> <span>🔒</span></h1><p class="text-lg md:text-xl text-slate-400 max-w-3xl mx-auto">探討資訊安全的核心：金鑰分發難題的演進與非對稱加密的誕生</header><main class="container mx-auto px-4 py-12 space-y-20"><section class="max-w-4xl mx-auto"><div class="card p-6 md:p-8"><h2 class="text-2xl font-bold text-white mb-4">📜 核心摘要</h2><p class="text-slate-300 leading-relaxed">本文從一個古代「如何安全寄送寶箱與鑰匙」的謎題出發，揭示了傳統<strong>對稱加密 (Symmetric Encryption)</strong> 所面臨的根本性挑戰——<strong>「金鑰分發難題」 (Key Distribution Problem)</strong>。 隨著運算需求的演進，此問題促使了 Martin Hellman 等先驅者尋找<strong>「單向函數」 (One-Way Function)</strong>，並最終催生了革命性的<strong>「非對稱加密」 (Asymmetric Encryption)</strong>。 本篇將說明 Diffie-Hellman 協定與 <strong>RSA (Rivest–Shamir–Adleman)</strong> 演算法的基礎原理，正是這些構想奠定了現代網路通訊安全的基石。</div></section><section class="grid grid-cols-1 gap-8 md:gap-12 items-center"><div class="space-y-4 max-w-3xl mx-auto text-center md:text-left"><h3 class="text-3xl font-bold text-white">📦 寶箱的困境：什麼是對稱加密？</h3><p>想像要寄送一個鎖上的寶箱，卻無法安全地將鑰匙交給收件人。這就是傳統密碼學的寫照。在<strong>對稱加密</strong>中，加密（上鎖）和解密（開鎖）使用的是<strong>同一把金鑰</strong>。<p>例如，在電腦世界中，最基礎的加密可透過「互斥或」 (XOR) 運算實現：將「原文」與「金鑰」進行 ⊕ 運算得到「密文」；收件人只需將「密文」與<strong>完全相同</strong>的「金鑰」再次 ⊕ 運算，即可還原出「原文」。<p>這種方法的致命傷在於：<strong>一旦金鑰在傳遞過程中被攔截，加密便形同虛設。</strong> 任何人只要拿到了這把鑰匙，就能解密所有訊息。這就是「金鑰分發難題」。</div></section><section class="space-y-8"><div class="text-center max-w-3xl mx-auto"><h3 class="text-3xl font-bold text-white mb-4">🕵️‍♂️ 竊聽風雲：對稱加密的致命缺陷</h3><p class="text-slate-400">使用對稱加密（如XOR）時，即使是看似巧妙的「三向傳遞」協定也極易被中間人破解。<div class="text-left max-w-lg mx-auto bg-gray-900/50 p-4 rounded-lg border border-slate-700 my-6"><h4 class="font-bold text-lg text-white mb-2">破解步驟一覽：</h4><ol class="list-decimal list-inside space-y-2 text-sm text-slate-300"><li><strong>Step 1:</strong> 小美 (Alice) 用她的金鑰 K1 加密訊息 M，發送 `M ⊕ K1`。<li><strong>Step 2:</strong> 中間人攔截並儲存 `M ⊕ K1`。<li><strong>Step 3:</strong> 小帥 (Bob) 收到後，再用他的金鑰 K2 加密，發回 `(M ⊕ K1) ⊕ K2`。<li><strong>Step 4:</strong> 中間人攔截並儲存 `M ⊕ K1 ⊕ K2`。<li><strong>Step 5:</strong> 小美收到後，移除自己的金鑰 K1，發回 `(M ⊕ K1 ⊕ K2) ⊕ K1`，即 `M ⊕ K2`。<li><strong>Step 6:</strong> 中間人攔截並儲存 `M ⊕ K2`。<li><strong>Step 7 (破解):</strong> 中間人將 (Step 4) 和 (Step 6) 的結果進行 ⊕ 運算，即 `(M ⊕ K1 ⊕ K2) ⊕ (M ⊕ K2)`，直接得到 <strong>K1</strong>。<li><strong>Step 8 (破解):</strong> 中間人再將剛得到的 <strong>K1</strong> 與 (Step 2) 的結果 ⊕ 運算，即 `K1 ⊕ (M ⊕ K1)`，最終得到原文 <strong>M</strong>。</ol></div><p class="text-slate-400"><strong>這暴露了對稱加密的根本局限性：</strong> 只要加密/解密的操作是可逆的，中間人就有機會透過收集到的訊息反推出金鑰或原文。 為了解決這個問題，必須引入「不可逆」的計算，也就是<strong>單向函數</strong>。<p class="text-slate-400 mt-4">以下動畫將演示此破解過程：</p><button id="start-animation-btn"class="mt-6 bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-6 rounded-lg transition duration-300 shadow-lg">▶️ 播放破解動畫</button></div><div id="animation-container"class="relative w-full max-w-5xl mx-auto p-4 card min-h-[350px] overflow-hidden"><div class="flex justify-between items-start mb-8 relative z-10"><div class="text-center w-1/3"><div class="text-2xl">👩‍🦰</div><div class="font-bold text-white">小美 (Alice)</div><div id="alice-calc"class="text-sm text-cyan-400 h-12"></div></div><div class="text-center w-1/3"><div class="text-2xl">🦹‍♂️</div><div class="font-bold text-white">中間人 (Attacker)</div><div id="attacker-calc"class="text-sm text-red-400 h-12"></div></div><div class="text-center w-1/3"><div class="text-2xl">👨‍🦱</div><div class="font-bold text-white">小帥 (Bob)</div><div id="bob-calc"class="text-sm text-emerald-400 h-12"></div></div></div><div class="absolute top-24 left-1/2 -translate-x-1/2 z-0 text-center w-2/5"><div class="font-mono text-xs text-slate-500">竊聽紀錄:</div><div id="attacker-log"class="mt-2 p-2 bg-gray-900 rounded-md h-32 font-mono text-left text-xs text-red-400 overflow-y-auto"></div><div id="attacker-result"class="mt-2 font-bold text-lg text-red-500 h-8"></div></div><div id="animated-message"class="absolute top-32 left-[15%] w-1/4 p-3 bg-cyan-600/50 border border-cyan-400 rounded-lg shadow-lg text-center font-mono text-sm text-white opacity-0"></div></div></section><section class="grid grid-cols-1 gap-8 md:gap-12 items-center"><div class="space-y-4 max-w-3xl mx-auto text-center md:text-left"><h3 class="text-3xl font-bold text-white">💡 靈光乍現：單向函數</h3><p>對稱加密的根本問題在於其「可逆性」——加密與解密同樣容易。為了解決這個問題，Hellman 敏銳地意識到，需要尋找一種特殊的數學函數：<strong>「單向函數」 (One-Way Function)</strong>。<p>這種函數的特性是：<strong>正向計算非常容易，但反向推導卻極其困難。</strong><p>一個經典的例子是<strong>「離散對數問題」 (Discrete Logarithm Problem)</strong>。給定數字 `x`, `a` 和質數 `p`，要計算 `k = x^a mod p` (x的a次方除以p的餘數) 非常快速。但是，如果只知道 `x`, `k` 和 `p`，要反推出指數 `a`，在計算上是極度困難的，除了暴力嘗試外沒有高效的方法。</div></section><section class="space-y-8"><div class="text-center max-w-3xl mx-auto"><h3 class="text-3xl font-bold text-white mb-4">💡 另一種靈光：大數質因數分解</h3><p class="text-slate-400">另一個更為著名的單向函數範例是<strong>「大數質因數分解」 (Integer Factorization)</strong>。 這也是 <strong>RSA (Rivest–Shamir–Adleman)</strong> 演算法的核心基礎。<p class="text-slate-400 mt-2">原理很簡單： <strong>正向計算（相乘）極其容易</strong>，即使是兩個非常巨大的質數，電腦也能瞬間算出它們的乘積。 <strong>反向推導（分解）極其困難</strong>，如果給中間人一個巨大的數字 N (乘積)，要求他找出當初相乘的兩個質數 P 和 Q，在有限時間內幾乎是不可能的任務。</div><div class="max-w-3xl mx-auto card p-6 md:p-8"><div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center"><div class="space-y-4 text-center p-4 bg-gray-900/50 rounded-lg"><h4 class="text-xl font-bold text-emerald-400">正向計算 (相乘) 🚀</h4><div class="font-mono text-lg"><div class="text-slate-300">P = 17,389 (質數 P)</div><div class="text-slate-300">Q = 29,989 (質數 Q)</div><div class="text-2xl text-white my-2">↓</div><div class="text-emerald-300 p-2 bg-emerald-900/50 rounded">N = 521,478,721</div></div><p class="text-sm text-slate-400">計算 N = P * Q <strong>(瞬間完成)</strong></div><div class="space-y-4 text-center p-4 bg-gray-900/50 rounded-lg"><h4 class="text-xl font-bold text-red-400">反向推導 (分解) 🐢</h4><div class="font-mono text-lg"><div class="text-slate-300">N = 521,478,721</div><div class="text-2xl text-white my-2">↓</div><div class="flex justify-center items-center h-[40px]"><span class="text-red-300 p-2 bg-red-900/50 rounded">P = ? &nbsp; Q = ?</span> <svg id="loader-icon"class="animate-spin h-5 w-5 text-red-400 ml-3"xmlns="http://www.w3.org/2000/svg"fill="none"viewBox="0 0 24 24"><circle class="opacity-25"cx="12"cy="12"r="10"stroke="currentColor"stroke-width="4"></circle><path class="opacity-75"fill="currentColor"d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div></div><p class="text-sm text-slate-400">找出 P 和 Q <strong>(計算上極度困難)</strong></div></div><p class="text-center text-slate-400 mt-6">在 RSA 中，這兩個巨大的質數 P 和 Q 正是構成<strong>私鑰 (Private Key)</strong> 的基礎，而它們的乘積 N 則是<strong>公鑰 (Public Key)</strong> 的一部分。中間人即使拿到公鑰 N，也無法反推出私鑰 P 和 Q。</div></section><section class="space-y-12"><div class="grid grid-cols-1 gap-8 md:gap-12 items-center"><div class="space-y-4 max-w-3xl mx-auto text-center md:text-left"><h3 class="text-3xl font-bold text-white">🔑 兩把鑰匙：非對稱加密的誕生</h3><p>利用「離散對數」這個強大的單向函數，Diffie 和 Hellman 提出了一種革命性的方法（此處簡化為 Shamir 三向傳遞協定的變體），成功解決了金鑰分發難題。<p>這套流程不再傳遞金鑰，而是傳遞經過單向函數計算後的「鎖」。<ol class="list-decimal list-inside space-y-2 text-slate-300 text-left"><li>小美選擇私鑰 <strong>a</strong>，計算 `M^a mod p` 並發送。<li>小帥選擇私鑰 <strong>b</strong>，計算 `(M^a)^b mod p = M^ab mod p` 並發回。<li>小美使用自己的私鑰 <strong>a</strong>「解鎖」，計算出 `M^b mod p` 並發回。<li>小帥使用自己的私鑰 <strong>b</strong>「解鎖」，最終得到原文 `M`。</ol><p>中間人雖然能竊聽到 `M^a`、`M^ab` 和 `M^b`，但由於離散對數的困難性，他無法在有效時間內反推出私鑰 `a` 或 `b`，因此無法破解訊息。</div></div><div class="grid grid-cols-1 gap-8 md:gap-12 items-center card p-6 md:p-8"><div class="space-y-4 max-w-3xl mx-auto text-center md:text-left"><h4 class="text-2xl font-bold text-white">🧮 如何「開鎖」？（開 A 次方）</h4><p>在上述流程中，小美如何從 `M^ab` 計算出 `M^b` 呢？這並不是簡單的開根號。<p>這需要運用數論中的<strong>「費馬小定理」 (Fermat's Little Theorem)</strong>。小美需要找到一個數字 `k`，使得 `ak ≡ 1 (mod p-1)`。這個 `k` 稱為 `a` 在 `mod p-1` 意義下的「數論倒數」。<p>計算 `(M^ab)^k mod p`，根據定理，這等同於 `M^b mod p`，從而巧妙地「移除」了自己的私鑰 `a`。小帥的解鎖過程亦同理。</div></div></section><section class="space-y-8"><div class="text-center max-w-3xl mx-auto"><h3 class="text-3xl font-bold text-white mb-4">🌐 現代基石：RSA 與數位簽章</h3><p class="text-slate-400">在 Diffie-Hellman 之後，<strong>RSA (Rivest–Shamir–Adleman)</strong> 演算法誕生。它基於我們前一節提到的<strong>大數質因數分解 (Factoring)</strong> 難題——將兩個超大質數相乘很容易，但要將其乘積反向分解回兩個質數則極其困難。<p class="text-slate-400 mt-2">RSA 真正確立了「公鑰」與「私鑰」的體系。<strong>公鑰 (Public Key)</strong> 用於加密（上鎖），可以昭告天下；<strong>私鑰 (Private Key)</strong> 用於解密（開鎖），僅由自己持有。這完美解決了⇅最初的寶箱謎題。</div><div class="max-w-3xl mx-auto card p-6 md:p-8 space-y-4"><h4 class="text-2xl font-bold text-white text-center">🔐 RSA 簡易範例：公鑰與私鑰的運作</h4><p class="text-slate-300">讓我們用一個簡單的例子（使用小質數）來說明完整的 RSA 流程：<div><h5 class="font-bold text-lg text-emerald-400">1. 訊息接收端 (小帥) 建立金鑰</h5><p class="text-sm text-slate-400 mb-2">小帥是訊息的「接收者」，他希望別人能安全地傳訊息給他。<ol class="list-decimal list-inside space-y-1 text-slate-300 pl-4"><li>選擇兩個質數: <code class="bg-gray-700 px-1 rounded">p = 3</code> 和 <code class="bg-gray-700 px-1 rounded">q = 11</code>。<li>計算公鑰 N: <code class="bg-gray-700 px-1 rounded">n = p * q = 3 * 11 = 33</code>。<li>計算 φ(n): <code class="bg-gray-700 px-1 rounded">φ(n) = (p-1)*(q-1) = 2 * 10 = 20</code>。<li>選擇公鑰 e (與 φ(n) 互質): <code class="bg-gray-700 px-1 rounded">e = 7</code>。<li>計算私鑰 d (使 <code class="bg-gray-700 px-1 rounded">(d*e) % φ(n) = 1</code>): <code class="bg-gray-700 px-1 rounded">d = 3</code> (因為 <code class="bg-gray-700 px-1 rounded">(3*7) % 20 = 21 % 20 = 1</code>)。<li><strong>私鑰 (Private Key)</strong> (自己保留): <strong>(d=3, n=33)</strong><li><strong>公鑰 (Public Key)</strong> (昭告天下): <strong>(e=7, n=33)</strong></ol></div><div><h5 class="font-bold text-lg text-cyan-400">2. 訊息發送端 (小美) 加密訊息</h5><p class="text-sm text-slate-400 mb-2">小美是訊息的「發送者」，她想傳送秘密訊息給小帥。<ol class="list-decimal list-inside space-y-1 text-slate-300 pl-4"><li>她想發送的原文訊息: <code class="bg-gray-700 px-1 rounded">m = 2</code>。<li>她查詢到小帥的<strong>公鑰 (e=7, n=33)</strong>。<li>加密計算 (c = m^e % n): <code class="bg-gray-700 px-1 rounded">c = 2^7 % 33 = 128 % 33 = 29</code>。<li>她將加密後的密文 <strong><code class="bg-gray-700 px-1 rounded">c = 29</code></strong> 發送給小帥。</ol></div><div><h5 class="font-bold text-lg text-emerald-400">3. 訊息接收端 (小帥) 解密訊息</h5><ol class="list-decimal list-inside space-y-1 text-slate-300 pl-4"><li>他收到了密文 <code class="bg-gray-700 px-1 rounded">c = 29</code>。<li>他使用自己的<strong>私鑰 (d=3, n=33)</strong> 來解密。<li>解密計算 (m = c^d % n): <code class="bg-gray-700 px-1 rounded">m = 29^3 % 33 = 24389 % 33 = 2</code>。<li>小帥成功還原出原文訊息 <strong><code class="bg-gray-700 px-1 rounded">m = 2</code></strong>。</ol></div><div class="pt-4 border-t border-slate-700"><h5 class="font-bold text-lg text-red-400">🦹‍♂️ 中間人 (Attacker) 得到了什麼？</h5><p class="text-slate-300">在整個過程中，中間人<strong>只能</strong>竊聽到公開的資訊：<ul class="list-disc list-inside space-y-1 text-slate-300 pl-4"><li>小帥的<strong>公鑰 (e=7, n=33)</strong>。<li>小美傳送的<strong>密文 (c=29)</strong>。</ul><p class="text-slate-300 mt-2">中間人若想破解 <code class="bg-gray-700 px-1 rounded">c=29</code>，就必須知道私鑰 <code class="bg-gray-700 px-1 rounded">d=3</code>。 要算出 <code class="bg-gray-700 px-1 rounded">d</code>，他就必須知道 <code class="bg-gray-700 px-1 rounded">φ(n)=20</code>。 要算出 <code class="bg-gray-700 px-1 rounded">φ(n)</code>，他就必須將 <code class="bg-gray-700 px-1 rounded">n=33</code> 質因數分解為 <code class="bg-gray-700 px-1 rounded">p=3</code> 和 <code class="bg-gray-700 px-1 rounded">q=11</code>。<p class="text-slate-300 mt-2">在這個範例中 <code class="bg-gray-700 px-1 rounded">n=33</code> 非常小，分解很容易。但如上一節動畫所示，如果 N 是一個2048位元（數百位數）的數字，質因數分解在有生之年內是無法完成的，這便確保了 RSA 的安全性。</div></div><div class="max-w-4xl mx-auto card overflow-hidden"><table class="w-full text-left"><thead class="bg-black/50 border-b border-slate-700"><tr><th class="p-4 text-white font-bold">特性<th class="p-4 text-white font-bold">對稱加密 (Symmetric)<th class="p-4 text-white font-bold">非對稱加密 (Asymmetric)<tbody class="divide-y divide-slate-800"><tr><td class="p-4 font-medium text-white">金鑰<td class="p-4">加密與解密使用 <strong>相同</strong> 金鑰<td class="p-4">使用 <strong>一對</strong> 金鑰：公鑰 (加密) 和 私鑰 (解密)<tr><td class="p-4 font-medium text-white">速度<td class="p-4">運算速度 <strong>快</strong><td class="p-4">運算速度 <strong>慢</strong> (涉及複雜數學運算)<tr><td class="p-4 font-medium text-white">主要用途<td class="p-4">大量資料的快速加密 (如檔案、串流)<td class="p-4">安全地交換金鑰、數位簽章<tr><td class="p-4 font-medium text-white">核心問題<td class="p-4"><strong>金鑰分發難題</strong> (如何安全傳遞金鑰)<td class="p-4">公鑰的真實性 (如何確認公鑰未被竄改)<tr><td class="p-4 font-medium text-white">範例<td class="p-4">AES, DES, XOR<td class="p-4">RSA, Diffie-Hellman, ElGamal</table></div></section><section class="max-w-4xl mx-auto"><div class="card p-6 md:p-8"><h3 class="text-3xl font-bold text-white mb-6 text-center">🤝 魚與熊掌兼得：現代混合加密</h3><p class="text-center text-slate-400 mb-8 max-w-2xl mx-auto">非對稱加密（如 RSA）非常安全，但運算緩慢；對稱加密（如 AES）速度極快，但有金鑰分發難題。 現代網路通訊 (如 HTTPS) 巧妙地結合了兩者，實現了「混合加密」 (Hybrid Encryption)：<div class="grid grid-cols-1 md:grid-cols-2 gap-8"><div class="bg-gray-900/50 p-6 rounded-lg border border-slate-700 text-center"><div class="text-5xl mb-4">🔒</div><h4 class="text-xl font-bold text-cyan-400 mb-2">第 1 階段：非對稱「握手」</h4><p class="text-slate-300">通訊剛建立時，使用<strong>非對稱加密</strong> (運算慢但安全)，安全地協商並交換一把<strong>「一次性」的對稱金鑰</strong> (也稱為 Session Key)。</div><div class="bg-gray-900/50 p-6 rounded-lg border border-slate-700 text-center"><div class="text-5xl mb-4">🚀</div><h4 class="text-xl font-bold text-emerald-400 mb-2">第 2 階段：對稱「傳輸」</h4><p class="text-slate-300">一旦雙方都擁有了這把安全的對稱金鑰，後續所有的資料傳輸都改用<strong>對稱加密</strong> (運算快又高效) 進行。</div></div><p class="text-center text-slate-300 mt-8 font-medium text-lg">這便是為何您的瀏覽器能瞬間載入 HTTPS 安全網頁的秘密——完美結合非對稱的『安全性』與對稱的『高效率』。</div></section><section class="text-center max-w-3xl mx-auto py-16"><h3 class="text-3xl font-bold text-white mb-4">✨ 總結：網路安全的黎明</h3><p class="text-slate-400 leading-relaxed">從一個簡單的「鎖匠謎題」，到支撐全球電子商務、安全通訊的複雜數學，非對稱加密的發明，是密碼學乃至整個電腦科學的偉大里程碑。它巧妙地利用了「計算的不可逆性」，在不安全的公開管道中，架設起了安全通訊的橋樑，使現代網路成為可能。</section></main><footer class="fixed bottom-0 left-0 w-full bg-gray-950 text-slate-500 text-center text-sm py-4 border-t border-slate-800 shadow-inner"><p><a href="https://wellstsai.com"target="_blank"rel="noopener noreferrer"class="hover:text-emerald-400 transition duration-300">Generated by wellstsai.com </a><span class="mx-2">|</span> 撰寫日期：2025年11月09日</footer><script>document.getElementById("start-animation-btn").addEventListener("click",function(){const t=this;t.disabled=!0,t.textContent="...破解中...",t.classList.add("opacity-50","cursor-not-allowed");const e=document.getElementById("animated-message"),n=document.getElementById("alice-calc"),s=document.getElementById("bob-calc"),r=document.getElementById("attacker-calc"),o=document.getElementById("attacker-log"),i=document.getElementById("attacker-result");e.style.transition="none",e.style.opacity=0,e.style.transform="translateX(0)",o.innerHTML="",i.innerHTML="",n.innerHTML="",s.innerHTML="",r.innerHTML="",e.offsetWidth,setTimeout(()=>{e.style.transition="transform 1.5s ease-in-out, opacity 0.5s ease-in-out"},10);let a={msg1:null,msg2:null,msg3:null};const l=t=>{o.innerHTML+=`<div>> ${t}</div>`,o.scrollTop=o.scrollHeight};setTimeout(()=>{n.innerHTML="M ⊕ K1",e.innerHTML="訊息 1 (M ⊕ K1)",e.style.opacity=1,e.style.transform="translateX(100%)"},500),setTimeout(()=>{r.innerHTML="攔截 訊息 1",a.msg1="M ⊕ K1",l("收到 訊息 1: M ⊕ K1"),e.style.transform="translateX(200%)"},2e3),setTimeout(()=>{s.innerHTML="(M ⊕ K1) ⊕ K2",e.innerHTML="訊息 2 (M ⊕ K1 ⊕ K2)",e.style.transform="translateX(100%)"},3500),setTimeout(()=>{r.innerHTML="攔截 訊息 2",a.msg2="M ⊕ K1 ⊕ K2",l("收到 訊息 2: M ⊕ K1 ⊕ K2"),e.style.transform="translateX(0)"},5e3),setTimeout(()=>{n.innerHTML="(M ⊕ K1 ⊕ K2) ⊕ K1 = M ⊕ K2",e.innerHTML="訊息 3 (M ⊕ K2)",e.style.transform="translateX(100%)"},6500),setTimeout(()=>{r.innerHTML="攔截 訊息 3",a.msg3="M ⊕ K2",l("收到 訊息 3: M ⊕ K2"),e.style.transform="translateX(200%)"},8e3),setTimeout(()=>{e.style.opacity=0,r.innerHTML="開始破解...",l("...開始計算...")},9500),setTimeout(()=>{r.innerHTML="計算 K1...",l("(訊息 2) ⊕ (訊息 3)"),l("= (M ⊕ K1 ⊕ K2) ⊕ (M ⊕ K2)"),l("= <strong>K1</strong> (已破解 K1)")},10500),setTimeout(()=>{r.innerHTML="計算 M...",l("(已破解 K1) ⊕ (訊息 1)"),l("= (K1) ⊕ (M ⊕ K1)"),l("= <strong>M</strong> (已破解原文)")},12e3),setTimeout(()=>{r.innerHTML="",i.innerHTML="🎉 破解成功！得到原文 M！",t.disabled=!1,t.textContent="▶️ 重新播放動畫",t.classList.remove("opacity-50","cursor-not-allowed")},13500)})</script>