<!doctypehtml><html lang="zh-Hant"><meta name="twitter:image"content="https://wellstsai.com/single-page-conclusion/%E8%A8%88%E7%AE%97%E6%A9%9F%E4%BD%8D%E5%85%83%E7%A7%BB%E4%BD%8D-%E5%BE%9E%E6%AD%A3%E5%8F%8D%E5%99%A8%E5%88%B0%E5%87%BD%E5%BC%8F.png"><meta name="twitter:description"content="說明「位元移位」如何從硬體的閂鎖與正反器開始，建構成移位暫存器，並演變為 CPU 的邏輯/算術指令。探討 >> 運算子的抽象漏洞與現代編譯器優化策略。"><meta name="twitter:title"content="從正反器到函式：計算機位元移位的全面解析"><meta name="twitter:card"content="summary_large_image"><meta property="og:type"content="article"><meta property="og:site_name"content="WellWells"><meta property="og:image"content="https://wellstsai.com/single-page-conclusion/%E8%A8%88%E7%AE%97%E6%A9%9F%E4%BD%8D%E5%85%83%E7%A7%BB%E4%BD%8D-%E5%BE%9E%E6%AD%A3%E5%8F%8D%E5%99%A8%E5%88%B0%E5%87%BD%E5%BC%8F.png"><meta property="og:url"content="https://wellstsai.com/single-page-conclusion/%E8%A8%88%E7%AE%97%E6%A9%9F%E4%BD%8D%E5%85%83%E7%A7%BB%E4%BD%8D-%E5%BE%9E%E6%AD%A3%E5%8F%8D%E5%99%A8%E5%88%B0%E5%87%BD%E5%BC%8F.html"><meta property="og:description"content="說明「位元移位」如何從硬體的閂鎖與正反器開始，建構成移位暫存器，並演變為 CPU 的邏輯/算術指令。探討 >> 運算子的抽象漏洞與現代編譯器優化策略。"><meta property="og:title"content="從正反器到函式：計算機位元移位的全面解析"><meta name="description"content="說明「位元移位」如何從硬體的閂鎖與正反器開始，建構成移位暫存器，並演變為 CPU 的邏輯/算術指令。探討 >> 運算子的抽象漏洞與現代編譯器優化策略。"><meta charset="UTF-8"><meta name="viewport"content="width=device-width,initial-scale=1"><title>從正反器到函式：計算機位元移位的全面解析</title><script src="https://cdn.tailwindcss.com"></script><link rel="preconnect"href="https://fonts.googleapis.com"><link rel="preconnect"href="https://fonts.gstatic.com"crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"rel="stylesheet"><style>body{font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,'Noto Sans',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol','Noto Color Emoji'}.gradient-text{background-image:linear-gradient(to right,var(--tw-gradient-stops));--tw-gradient-from:#38bdf8;--tw-gradient-to:#c084fc;--tw-gradient-stops:var(--tw-gradient-from),var(--tw-gradient-to);-webkit-background-clip:text;background-clip:text;color:transparent}.keyword{color:#38bdf8;font-weight:600;cursor:help;border-bottom:1px dotted #38bdf8;transition:all .2s ease-in-out}.keyword:hover{color:#c084fc;border-bottom-color:#c084fc;background-color:rgba(51,65,85,.5)}#tooltip{position:absolute;display:none;background-color:#1e293b;color:#e2e8f0;border:1px solid #334155;border-radius:.5rem;padding:.75rem;box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05);z-index:50;max-width:300px;pointer-events:none;opacity:.95}#tooltip-title{font-weight:700;font-size:1.125rem;color:#e2e8f0;margin-bottom:.5rem}#tooltip-desc{font-size:.875rem;color:#94a3b8}#tooltip-detail{font-size:.75rem;color:#64748b;margin-top:.75rem;padding-top:.75rem;border-top:1px solid #334155}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-JKC4KZLT26"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JKC4KZLT26")</script><body class="bg-slate-900 text-slate-300 antialiased"><header class="text-center py-16 md:py-24 px-4"><h1 class="gradient-text text-4xl md:text-6xl font-bold mb-4">從正反器到函式</h1><h2 class="text-xl md:text-2xl font-bold mb-6 text-slate-200">計算機位元移位的全面解析</h2><p class="text-lg text-slate-400 max-w-3xl mx-auto">深入探討資料如何從最底層的硬體電路流動，穿越 CPU 架構，最終成為高階程式語言中的抽象運算子。</header><section class="max-w-3xl mx-auto px-4 mb-16"><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6 md:p-8"><h3 class="text-2xl font-bold text-sky-400 mb-4">執行摘要</h3><p class="text-base leading-relaxed text-slate-300">本文追溯了「位元移位」操作的完整生命週期。起點是<span class="keyword"data-keyword="閂鎖">閂鎖</span>與<span class="keyword"data-keyword="正反器">正反器</span>，我們解析了為何<strong>邊緣觸發</strong>機制是解決<strong>競爭條件</strong>、建立可靠<span class="keyword"data-keyword="序向邏輯">序向邏輯</span>的關鍵。接著，我們探討由正反器構成的<span class="keyword"data-keyword="移位暫存器">移位暫存器</span>如何透過<span class="keyword"data-keyword="多工器">多工器</span>（MUX）實現資料的串並列轉換與路由。<br><br>然後，我們將硬體映射到軟體，區分了 CPU 的<strong><span class="keyword"data-keyword="邏輯移位">邏輯</span></strong>與<strong><span class="keyword"data-keyword="算術移位">算術</span></strong>指令，並揭示了高階語言（如 C++ / Java）中 <code>&gt;&gt;</code> 運算子<strong>依賴資料型態</strong>的「有漏洞的抽象」。最後，我們提供了現代工程實踐：在多數情況下，程式設計師應<strong>為意圖而編碼</strong>（例如使用 <code>* 2</code> 而非 <code>&lt;&lt; 1</code>），並<strong>信任編譯器</strong>執行<span class="keyword"data-keyword="強度折減">強度折減</span>優化，僅在嵌入式或硬體互動等特定領域才進行手動位元控制。</div></section><main class="max-w-7xl mx-auto px-4"><section class="py-12 md:py-16"><h2 class="text-3xl font-bold gradient-text mb-12 text-center">第一節：記憶的量子：閂鎖與正反器的基礎</h2><div class="grid md:grid-cols-2 gap-8"><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6 flex flex-col"><span class="text-4xl mb-4">💡</span><h3 class="text-2xl font-bold text-sky-400 mb-3">D 型閂鎖 (D-Latch)</h3><p class="text-slate-400 leading-relaxed">數位記憶的基礎，其核心特性是「<strong><span class="keyword"data-keyword="電位觸發">電位觸發</span></strong>」。當致能訊號為高電位時，閂鎖會變得「<strong><span class="keyword"data-keyword="通透">通透</span></strong>」，輸出 (Q) 會<strong>即時複製</strong>輸入 (D) 的狀態。</div><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6 flex flex-col"><span class="text-4xl mb-4">⚠️</span><h3 class="text-2xl font-bold text-yellow-400 mb-3">通透性的隱患</h3><p class="text-slate-400 leading-relaxed">當多個閂鎖串接並共享同一時脈，通透性會導致訊號在單一時脈週期內<strong>不受控制地一路傳播</strong>到鏈路末端。這被稱為「<strong><span class="keyword"data-keyword="競爭條件">競爭條件</span></strong>」（Race Condition），使可靠的同步移位變得不可能。</div><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6 flex flex-col"><span class="text-4xl mb-4">🔒</span><h3 class="text-2xl font-bold text-green-400 mb-3">D 型正反器 (D-Flip-Flop)</h3><p class="text-slate-400 leading-relaxed">解決方案是「<strong><span class="keyword"data-keyword="邊緣觸發">邊緣觸發</span></strong>」。正反器<strong>只在時脈訊號發生轉換的極短暫瞬間</strong>（正緣或負緣）才會對輸入進行取樣。這徹底打破了通透鏈，確保資料在每個時脈週期<strong>只前進一個階段</strong>。</div><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6 flex flex-col"><span class="text-4xl mb-4">🏗️</span><h3 class="text-2xl font-bold text-purple-400 mb-3">主從式 (Master-Slave) 架構</h3><p class="text-slate-400 leading-relaxed">邊緣觸發的經典實現。本質上是<strong>由兩個 D-latch 串聯</strong>構成，並使用反相的時脈訊號。這創造了一個「<strong>先取樣、後傳播</strong>」的兩階段過程，是所有同步數位設計的基石。</div></div><h3 class="text-2xl font-bold text-center mt-16 mb-8 text-slate-200">D-Latch vs D-Flip-Flop 關鍵比較</h3><div class="overflow-x-auto shadow-lg rounded-lg border border-slate-700"><table class="w-full min-w-lg text-left bg-slate-800/80"><thead class="bg-slate-700/50"><tr><th class="p-4 font-semibold text-sky-400">項目<th class="p-4 font-semibold text-slate-200">D-latch (電位觸發)<th class="p-4 font-semibold text-slate-200">D flip-flop (邊緣觸發)<tbody class="divide-y divide-slate-700/50"><tr class="hover:bg-slate-700/50 transition-colors"><td class="p-4 font-medium">觸發方式<td class="p-4 text-slate-400">以致能訊號的<strong>電位</strong>（高/低）控制<td class="p-4 text-slate-400">以時脈訊號的<strong>邊緣</strong>（上升/下降）瞬間寫入<tr class="hover:bg-slate-700/50 transition-colors"><td class="p-4 font-medium">寫入窗口<td class="p-4 text-slate-400">持續（通透）<td class="p-4 text-slate-400">極短暫（瞬間）<tr class="hover:bg-slate-700/50 transition-colors"><td class="p-4 font-medium">串接行為<td class="p-4 text-slate-400"><strong class="text-yellow-400">易產生競爭條件</strong><td class="p-4 text-slate-400"><strong class="text-green-400">避免競爭條件</strong>，確保同步<tr class="hover:bg-slate-700/50 transition-colors"><td class="p-4 font-medium">主要用途<td class="p-4 text-slate-400">簡單資料暫存、非同步電路<td class="p-4 text-slate-400">暫存器、計數器、狀態機等<strong>同步電路</strong></table></div></section><section class="py-12 md:py-16"><h2 class="text-3xl font-bold gradient-text mb-12 text-center">第二節：編排資料流：移位暫存器的架構</h2><div class="grid md:grid-cols-3 gap-8"><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6"><span class="text-4xl mb-4">🔄</span><h3 class="text-2xl font-bold text-sky-400 mb-3">串列 (Serial) vs 並列 (Parallel)</h3><p class="text-slate-400 leading-relaxed"><span class="keyword"data-keyword="移位暫存器">移位暫存器</span>是串列與並列資料領域的橋樑。<br><strong><span class="keyword"data-keyword="SIPO">SIPO</span> (串入並出):</strong> 將串列位元流（如 UART 接收）轉換為 CPU 可讀取的並列位元組。<br><strong><span class="keyword"data-keyword="PISO">PISO</span> (並入串出):</strong> 將並列位元組轉換為串列位元流（如 UART 發送）。</div><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6"><span class="text-4xl mb-4">⚙️</span><h3 class="text-2xl font-bold text-purple-400 mb-3">通用移位暫存器</h3><p class="text-slate-400 leading-relaxed">功能最強大的設計。其核心是在每個正反器的 D 輸入端使用一個 <strong><span class="keyword"data-keyword="多工器">多工器</span> (MUX)</strong>。透過選擇線 (S0, S1)，MUX 可以決定下一個狀態是來自：<br>1. <strong>保持</strong> (自身 Q 輸出)<br>2. <strong>向右移位</strong> (左側鄰居)<br>3. <strong>向左移位</strong> (右側鄰居)<br>4. <strong>並列載入</strong> (外部資料)</div><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6"><span class="text-4xl mb-4">♻️</span><h3 class="text-2xl font-bold text-green-400 mb-3">循環移位 (旋轉)</h3><p class="text-slate-400 leading-relaxed">一種特殊的移位，<strong>不會丟失任何位元</strong>。從一端移出的位元會被重新插入到另一端。<br><strong>ROL (Rotate Left):</strong> 最左位元移至最右。<br><strong>ROR (Rotate Right):</strong> 最右位元移至最左。<br>此操作在密碼學和雜湊演算法中至關重要。</div></div></section><section class="py-12 md:py-16"><h2 class="text-3xl font-bold gradient-text mb-12 text-center">第三節：從矽晶到語法：CPU 與程式語言</h2><div class="grid md:grid-cols-2 gap-8"><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6"><span class="text-4xl mb-4">🧠</span><h3 class="text-2xl font-bold text-sky-400 mb-3">CPU 的移位指令 (ISA)</h3><p class="text-slate-400 leading-relaxed">CPU 提供了三種主要移位指令：<br>1. <strong><span class="keyword"data-keyword="邏輯移位">邏輯移位 (Logical)</span>:</strong> 將操作數視為單純位元，空位<strong>永遠補 0</strong>。用於無正負號整數或位元遮罩。<br>2. <strong><span class="keyword"data-keyword="算術移位">算術移位 (Arithmetic)</span>:</strong> 專為<span class="keyword"data-keyword="二補數">二補數</span>（帶正負號）整數設計。右移時，空位會複製<strong>原始的符號位</strong>（<span class="keyword"data-keyword="符號擴展">符號擴展</span>），以保持數值的正負號。<br>3. <strong><span class="keyword"data-keyword="循環移位">循環移位 (Rotate)</span>:</strong> 如前所述，用於演算法。</div><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6"><span class="text-4xl mb-4">💻</span><h3 class="text-2xl font-bold text-purple-400 mb-3">語言運算子 (<code>&gt;&gt;</code>)</h3><p class="text-slate-400 leading-relaxed">高階語言的 <code>&gt;&gt;</code> 運算子是一個「<strong>有漏洞的抽象</strong>」：<br>• <code>&lt;&lt;</code> (左移): 行為很單純，空位總是補 0。<br>• <code>&gt;&gt;</code> (右移): <strong>行為依賴於資料類型！</strong><br>- 對 <strong>unsigned</strong> 型態：編譯器生成<strong>邏輯右移</strong>（補 0）。<br>- 對 <strong>signed</strong> 型態：編譯器生成<strong>算術右移</strong>（補符號位）。<br><br>(註：Java 額外提供了 <code>&gt;&gt;&gt;</code> 運算子來強制執行邏輯右移。)</div></div></section><section class="py-12 md:py-16"><h2 class="text-3xl font-bold gradient-text mb-12 text-center">第四節：位元的力量：實際應用技巧</h2><div class="grid md:grid-cols-3 gap-8"><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6"><span class="text-4xl mb-4">🚀</span><h3 class="text-2xl font-bold text-green-400 mb-3">高速算術運算</h3><p class="text-slate-400 leading-relaxed">位元移位是乘除法（當乘數/除數為 2 的冪次方時）的快速替代方案。<br>• <code>x * 8</code> 可替換為 <code>x &lt;&lt; 3</code><br>• <code>x / 4</code> 可替換為 <code>x &gt;&gt; 2</code><br>這是一種手動的「<span class="keyword"data-keyword="強度折減">強度折減</span>」，在遊戲引擎、圖形渲染中非常重要。</div><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6"><span class="text-4xl mb-4">🚩</span><h3 class="text-2xl font-bold text-yellow-400 mb-3">資料壓縮：位元旗標</h3><p class="text-slate-400 leading-relaxed">將多個布林狀態壓縮到單一整數中，極大節省記憶體。<br>• <strong>設定第 N 位:</strong><br><code>flags |= (1 &lt;&lt; N)</code><br>• <strong>清除第 N 位:</strong><br><code>flags &= ~(1 &lt;&lt; N)</code><br>• <strong>檢查第 N 位:</strong><br><code>if (flags & (1 &lt;&lt; N))</code><br>廣泛應用於作業系統權限、硬體暫存器。</div><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6"><span class="text-4xl mb-4">🎨</span><h3 class="text-2xl font-bold text-sky-400 mb-3">資料提取：RGBA 顏色</h3><p class="text-slate-400 leading-relaxed">在圖形處理中，將四個 8 位元的顏色通道 (R, G, B, A) 封裝到一個 32 位元整數中。<br><strong>封裝:</strong><br><code>(a &lt;&lt; 24) | (b &lt;&lt; 16) | (g &lt;&lt; 8) | r</code><br><strong>提取藍色 (B):</strong><br><code>(color &gt;&gt; 16) & 0xFF</code><br>移位負責「定位」，AND (<code>&</code>) 負責「提取」。</div></div></section><section class="py-12 md:py-16"><h2 class="text-3xl font-bold gradient-text mb-12 text-center">第五節：現代視角：優化、編譯器與實踐</h2><div class="grid md:grid-cols-2 gap-8"><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6"><span class="text-4xl mb-4">🤖</span><h3 class="text-2xl font-bold text-green-400 mb-3">編譯器的智慧：自動強度折減</h3><p class="text-slate-400 leading-relaxed">一個常見誤解是程式設計師需要手動將 <code>x * 8</code> 改寫為 <code>x &lt;&lt; 3</code>。<br><br><strong>事實是：</strong>現代優化編譯器 (GCC, Clang) 會<strong>自動執行<span class="keyword"data-keyword="強度折減">強度折減</span></strong>。當編譯器看到 <code>x * 12</code>，它會自動將其轉換為 <code>(x &lt;&lt; 3) + (x &lt;&lt; 2)</code>，這通常比手動編寫的程式碼更優。<br><br><strong>結論：信任你的編譯器。</strong></div><div class="bg-slate-800/80 border border-slate-700 rounded-lg shadow-lg p-6"><span class="text-4xl mb-4">✍️</span><h3 class="text-2xl font-bold text-sky-400 mb-3">為意圖而編碼 (Code for Intent)</h3><p class="text-slate-400 leading-relaxed">手動將 <code>x * 2</code> 寫成 <code>x &lt;&lt; 1</code> 是一種「<strong><span class="keyword"data-keyword="過早優化">過早優化</span></strong>」，它：<br>1. <strong>損害可讀性:</strong> <code>x * 2</code> 表達了「乘法」的意圖；<code>x &lt;&lt; 1</code> 暴露了「實現機制」。<br>2. <strong>功能冗餘:</strong> 編譯器會生成完全相同的機器碼。<br>3. <strong>代碼脆弱:</strong> 未來維護者很難修改。<br><br><strong>例外：</strong>在嵌入式系統、韌體、或<strong>直接操作硬體暫存器</strong>時，使用位元操作是必要且最清晰的意圖表達。</div></div></section><section class="py-16 max-w-3xl mx-auto px-4"><h2 class="text-3xl font-bold gradient-text mb-6">總結：現代工程師的策略</h2><p class="text-lg leading-relaxed text-slate-300">位元移位是貫穿電腦科學軟硬體層次的核心脈絡。理解其硬體實現，有助於我們明瞭同步設計的精髓。<br><br>然而，在應用層面，<strong>程式設計師的角色已經演變</strong>。我們應與編譯器協作：<strong>我們提供高層次的語意和清晰意圖，編譯器負責底層的微觀優化。</strong><br><br><strong>為意圖而編碼</strong>。如果你的意圖是乘法，就使用 <code>*</code>；如果你的意圖是操作位元旗標，才使用 <code>&lt;&lt;</code> 和 <code>|</code>。</section></main><footer class="bg-slate-800 text-center py-6 mt-16"><p class="text-sm text-slate-400"><a href="https://wellstsai.com"target="_blank"rel="noopener noreferrer"class="hover:text-sky-400 transition-colors duration-200">Generated by wellstsai.com</a><p class="text-sm text-slate-500 mt-2">撰寫日期：2025年10月25日</footer><div id="tooltip"><h4 id="tooltip-title"></h4><p id="tooltip-desc"><p id="tooltip-detail"></div><script>document.addEventListener("DOMContentLoaded",()=>{const e={"閂鎖":{title:"閂鎖 (Latch)",desc:"一種記憶元件，其輸出由控制訊號的『電位』決定。",detail:"D-Latch 在致能（Enable）訊號為高電位時會變得『通透』，輸出即時跟隨輸入。"},"正反器":{title:"正反器 (Flip-Flop)",desc:"一種記憶元件，其輸出僅在控制訊號的『邊緣』瞬間更新。",detail:"D-Flip-Flop 只在時脈的上升緣或下降緣取樣輸入，避免了競爭條件。"},"電位觸發":{title:"電位觸發 (Level-Triggered)",desc:"指電路的行為由控制訊號處於某個『電位』（例如高電位）的『期間』所決定。",detail:"這是閂鎖（Latch）的特性，也是其『通透性』的來源。"},"邊緣觸發":{title:"邊緣觸發 (Edge-Triggered)",desc:"指電路的行為僅由控制訊號發生『轉變』（例如從低到高）的『瞬間』所決定。",detail:"這是正反器（Flip-Flop）的特性，也是同步系統的基礎。"},"通透":{title:"通透 (Transparent)",desc:"指閂鎖在致能狀態下，其輸出 (Q) 會即時且持續地複製輸入 (D) 的狀態。",detail:"任何在 D 上的變化都會立即傳遞到 Q，彷彿電路是透明的。"},"競爭條件":{title:"競爭條件 (Race Condition)",desc:"在串接的『通透』閂鎖中，訊號在單一時脈週期內不受控地傳播，導致最終狀態不可預測。",detail:"電路的最終結果取決於哪個訊號『跑得比較快』，這是同步設計的大敵。"},"主從式":{title:"主從式 (Master-Slave)",desc:"實現邊緣觸發正反器的經典架構，由兩個串聯的閂鎖（主、從）構成。",detail:"時脈的一個階段『主閂鎖』取樣，另一個階段『從閂鎖』輸出，實現『先取樣、後傳播』。"},"移位暫存器":{title:"移位暫存器 (Shift Register)",desc:"由一系列串接的正反器組成，能在時脈驅動下，系統性地移動（移位）儲存的資料。",detail:"是串列/並列資料轉換的關鍵元件。"},SISO:{title:"SISO (Serial-In, Serial-Out)",desc:"串列輸入，串列輸出。資料逐位元移入，也逐位元移出。",detail:"常用作數位延遲線（Digital Delay Line）。"},SIPO:{title:"SIPO (Serial-In, Parallel-Out)",desc:"串列輸入，並列輸出。將串列位元流轉換為並列資料字。",detail:"例如，串列通訊（UART）的接收端。"},PISO:{title:"PISO (Parallel-In, Serial-Out)",desc:"並列輸入，串列輸出。將並列資料字轉換為串列位元流。",detail:"例如，串列通訊（UART）的發送端。"},"多工器":{title:"多工器 (Multiplexer, MUX)",desc:'一種<span class="keyword" data-keyword="組合邏輯">組合邏輯</span>電路，可從多個輸入訊號中選擇一個作為輸出。',detail:"在通用移位暫存器中，MUX 扮演『資料路由』的角色，決定下一個狀態是來自左側、右側、自身還是外部。"},"通用移位暫存器":{title:"通用移位暫存器 (Universal Shift Register)",desc:"功能最全面的移位暫存器，可執行保持、左移、右移和並列載入。",detail:"透過 MUX（多工器）來選擇四種操作模式之一。"},"循環移位":{title:"循環移位 (Circular Shift / Rotate)",desc:"一種特殊的移位，從一端移出的位元會被重新插入到另一端，不丟失任何資訊。",detail:"在密碼學和雜湊演算法中用於位元置換（Permutation）。"},"邏輯移位":{title:"邏輯移位 (Logical Shift)",desc:"將資料視為單純的位元序列，空出的位元位置永遠被填入 0。",detail:"對應 C 語言中對『unsigned』(無正負號) 整數的右移。"},"算術移位":{title:"算術移位 (Arithmetic Shift)",desc:"專為帶正負號的整數設計。右移時，空位會複製原始的『符號位』。",detail:"對應 C 語言中對『signed』(帶正負號) 整數的右移。"},"符號擴展":{title:"符號擴展 (Sign Extension)",desc:"在算術右移中，用原始的符號位（MSB）填充空出的高位。",detail:"目的是在執行等效的『除法』操作後，保持數值的正負號不變。"},"強度折減":{title:"強度折減 (Strength Reduction)",desc:"一種編譯器優化技術，用執行速度更快（強度較低）的操作來替換昂貴（強度較高）的操作。",detail:"例如，將 `x * 8`（乘法）替換為 `x << 3`（位元移位）。現代編譯器會自動完成此操作。"},"位元旗標":{title:"位元旗標 (Bit Flags)",desc:"一種將多個布林（boolean）狀態壓縮到單一整數中的技術。",detail:"例如，一個 32 位元整數可以儲存 32 個獨立的開關狀態，極大節省記憶體。"},"RGBA 顏色封裝":{title:"RGBA 顏色封裝 (RGBA Color Packing)",desc:"在圖形學中，將四個 8 位元的顏色通道 (R, G, B, A) 封裝到一個 32 位元整數中的技術。",detail:"例如：`color = (a << 24) | (b << 16) | (g << 8) | r`。"},"過早優化":{title:"過早優化 (Premature Optimization)",desc:"在沒有數據（Profiler）支持的情況下，為了猜測的性能提升而犧牲程式碼可讀性或設計。",detail:"將 `x * 2` 手動改寫為 `x << 1` 是典型範例，因為編譯器已能完美處理。"},"組合邏輯":{title:"組合邏輯 (Combinational Logic)",desc:"一種數位電路，其輸出『僅』取決於『當前』的輸入狀態。",detail:"例如 AND 閘、OR 閘、多工器（MUX）。沒有記憶功能。"},"序向邏輯":{title:"序向邏輯 (Sequential Logic)",desc:"一種數位電路，其輸出不僅取決於當前輸入，還取決於電路的『過去狀態』（即記憶）。",detail:"閂鎖和正反器是構成序向邏輯的基礎元件。"},"二補數":{title:"二補數 (Two's Complement)",desc:"現代電腦系統中用於表示帶正負號整數的標準方法。",detail:"最高位元（MSB）為 0 代表正數，為 1 代表負數。算術移位專為此表示法設計。"}},t=document.getElementById("tooltip"),i=document.getElementById("tooltip-title"),l=document.getElementById("tooltip-desc"),d=document.getElementById("tooltip-detail");document.querySelectorAll(".keyword").forEach(a=>{let o=a.dataset.keyword,n=e[o];a.addEventListener("mouseover",e=>{n&&(i.innerHTML=n.title,l.innerHTML=n.desc,d.innerHTML=n.detail,t.style.display="block")}),a.addEventListener("mousemove",e=>{let i=e.pageX+10,l=e.pageY+10;i+t.offsetWidth>window.innerWidth+window.scrollX&&(i=e.pageX-t.offsetWidth-10),l+t.offsetHeight>window.innerHeight+window.scrollY&&(l=e.pageY-t.offsetHeight-10),t.style.left=i+"px",t.style.top=l+"px"}),a.addEventListener("mouseout",()=>{t.style.display="none"})})})</script>