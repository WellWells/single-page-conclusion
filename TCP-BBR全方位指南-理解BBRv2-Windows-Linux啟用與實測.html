<!doctypehtml><html lang="zh-Hant"><meta name="twitter:image"content="https://wellstsai.com/single-page-conclusion/TCP-BBR%E5%85%A8%E6%96%B9%E4%BD%8D%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3BBRv2-Windows-Linux%E5%95%9F%E7%94%A8%E8%88%87%E5%AF%A6%E6%B8%AC.png"><meta name="twitter:description"content="什麼是 TCP BBR？本文說明 BBR 如何利用 BDP 模型戰勝 CUBIC 的緩衝區膨脹問題。提供 Windows 11 (BBRv2) 與 Linux 啟用教學，以及 iperf3 效能驗證方法。"><meta name="twitter:title"content="TCP BBR 全方位指南：理解 BBRv2、Windows/Linux 啟用與實測"><meta name="twitter:card"content="summary_large_image"><meta property="og:type"content="article"><meta property="og:site_name"content="WellWells"><meta property="og:image"content="https://wellstsai.com/single-page-conclusion/TCP-BBR%E5%85%A8%E6%96%B9%E4%BD%8D%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3BBRv2-Windows-Linux%E5%95%9F%E7%94%A8%E8%88%87%E5%AF%A6%E6%B8%AC.png"><meta property="og:url"content="https://wellstsai.com/single-page-conclusion/TCP-BBR%E5%85%A8%E6%96%B9%E4%BD%8D%E6%8C%87%E5%8D%97-%E7%90%86%E8%A7%A3BBRv2-Windows-Linux%E5%95%9F%E7%94%A8%E8%88%87%E5%AF%A6%E6%B8%AC.html"><meta property="og:description"content="什麼是 TCP BBR？本文說明 BBR 如何利用 BDP 模型戰勝 CUBIC 的緩衝區膨脹問題。提供 Windows 11 (BBRv2) 與 Linux 啟用教學，以及 iperf3 效能驗證方法。"><meta property="og:title"content="TCP BBR 全方位指南：理解 BBRv2、Windows/Linux 啟用與實測"><meta name="description"content="什麼是 TCP BBR？本文說明 BBR 如何利用 BDP 模型戰勝 CUBIC 的緩衝區膨脹問題。提供 Windows 11 (BBRv2) 與 Linux 啟用教學，以及 iperf3 效能驗證方法。"><meta charset="UTF-8"><meta name="viewport"content="width=device-width,initial-scale=1"><title>TCP BBR 全方位技術指南與說明</title><script src="https://cdn.tailwindcss.com"></script><link rel="preconnect"href="https://fonts.googleapis.com"><link rel="preconnect"href="https://fonts.gstatic.com"crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"rel="stylesheet"><link rel="stylesheet"href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css"xintegrity="sha384-gGcqcVCCdJOhgKCFVlCb/xr0lzNr3JmoGytua8RMwS/A/CegQ+T+i+gLWPvWfJLY"crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"xintegrity="sha384-7K3DWG3Z2f/Eyz+QVW6SoNqYq+yVmZcM/1M0O/E2/CRdHXv2RjR+o/tcjA2+xqrW"crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"xintegrity="sha384-RcHnSGoV/oIHL00I/CUIQG0TjJ/aOi2GQR/10A+C/hvM/Fctb23IqQJBEg3O/k+W"crossorigin="anonymous"></script><style>body{font-family:Inter,'Noto Sans TC',sans-serif;background-color:#0f172a;color:#e2e8f0;overflow-x:hidden}.gradient-text{background:linear-gradient(to bottom,#38bdf8,#c084fc);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;text-fill-color:transparent}.keyword{cursor:help;border-bottom:2px dotted #64748b;transition:all .2s ease-in-out}.keyword:hover{border-bottom-color:#38bdf8;color:#38bdf8}#tooltip{position:absolute;display:none;padding:1rem;background-color:rgba(30,41,59,.95);border:1px solid #334155;border-radius:.5rem;box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05);z-index:50;pointer-events:none;max-width:90vw}#tooltip h3{font-weight:600;color:#38bdf8;margin-bottom:.5rem}#tooltip p{font-size:.875rem;color:#cbd5e1;line-height:1.5}#tooltip code{background-color:#0f172a;padding:.125rem .375rem;border-radius:.25rem;font-size:.875rem}.card{background-color:rgba(30,41,59,.7);backdrop-filter:blur(8px);border:1px solid #334155;border-radius:.75rem;box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06);overflow:hidden}td,th{border-color:#334155;padding:.75rem 1rem}thead th{background-color:#1e293b}tbody tr:hover{background-color:#1e293b}footer{background-color:#020617;color:#64748b;border-top:1px solid #1e293b}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-JKC4KZLT26"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JKC4KZLT26")</script><body class="flex flex-col min-h-screen"><div id="tooltip"></div><main class="flex-grow container mx-auto px-4 py-16 sm:py-24"><header class="text-center mb-16"><h1 class="text-4xl sm:text-6xl font-bold mb-4">🚀 <span class="gradient-text">TCP BBR 全方位技術指南</span></h1><p class="text-xl sm:text-2xl text-slate-400 max-w-3xl mx-auto">從「基於遺失」到「基於模型」：深入理解 BBR、BBRv2，並學習如何在 Windows 與 Linux 上啟用及驗證效能。</header><section class="mb-16"><div class="card max-w-4xl mx-auto p-6 sm:p-8"><h2 class="text-2xl font-semibold mb-4 text-center"><span class="gradient-text">核心摘要：BBR 為何重要？</span></h2><ul class="space-y-3 text-slate-300"><li class="flex items-start"><span class="text-sky-400 mr-3">✅</span><div><strong>高吞吐量：</strong> BBR 旨在<strong>充分利用網路頻寬</strong>，尤其在有損耗的長距離鏈路上，效能遠超 <span class="keyword"data-keyword="cubic">CUBIC</span>。</div><li class="flex items-start"><span class="text-sky-400 mr-3">✅</span><div><strong>低延遲：</strong> BBR 主動避免填滿網路緩衝區，有效對抗 <span class="keyword"data-keyword="bufferbloat">緩衝區膨脹</span>，提供穩定的低延遲，對遊戲和視訊會議至關重要。</div><li class="flex items-start"><span class="text-sky-400 mr-3">✅</span><div><strong>BBRv2 的演進：</strong> Windows 11 採用的 <span class="keyword"data-keyword="bbr2">BBRv2</span> 修正了 BBRv1 的侵略性，學會對封包遺失做出反應，實現了<strong>效能與網路公平性</strong>之間的平衡。</div></ul></div></section><div class="space-y-16 mb-16"><section class="max-w-5xl mx-auto"><h2 class="text-3xl font-bold mb-6 text-center">📦 <span class="gradient-text">基礎中的基礎：什麼是「封包」？</span></h2><div class="card p-6 sm:p-8"><p class="text-lg text-slate-300 leading-relaxed">想像一下，你要寄送一張巨大的拼圖。你不會把整張拼圖塞進一個信封，而是會把它拆成 1000 片，每一片都裝進一個小信封，並在信封上標記「這是第 1 片」、「這是第 2 片」...<p class="text-lg text-slate-300 leading-relaxed mt-4">在網路上，<strong>「封包」(Packet) 就是那些小信封</strong>。<p class="text-lg text-slate-300 leading-relaxed mt-4">無論你是在下載遊戲、看影片或傳送訊息，你所有的資料都會被作業系統切成數千個小「封包」。每個封包都獨立地在網際網路上傳送，最後在你的電腦上被重新組合起來。</div></section><section class="max-w-5xl mx-auto"><h2 class="text-3xl font-bold mb-6 text-center">📉 <span class="gradient-text">什麼是「封包遺失」？它會怎樣？</span></h2><p class="text-lg text-slate-400 text-center mb-8 max-w-3xl mx-auto">延續拼圖的比喻：如果在運送過程中，第 500 片拼圖的小信封（封包）不見了，這就是「封包遺失」。<div class="grid md:grid-cols-2 gap-6"><div class="card p-6"><h3 class="text-xl font-semibold mb-3">為什麼會遺失？</h3><ul class="list-disc list-inside text-slate-300 space-y-2"><li><strong>網路壅塞 (最常見)：</strong> 路由器（網路的交通警察）的「信箱」滿了，新的信封（封包）塞不進去，只好直接丟掉。<li><strong>訊號不良：</strong> 你的 WiFi 或 4G/5G 訊號太弱，導致資料在空中傳輸時損毀。<li><strong>物理問題：</strong> 網路線接觸不良或損壞。</ul></div><div class="card p-6"><h3 class="text-xl font-semibold mb-3">遺失會怎樣？下載變慢還是高延遲？</h3><p class="text-slate-300"><strong>主要後果是：下載速度降低 (低吞吐量)。</strong><p class="text-slate-400 mt-2">當你的電腦（收件人）發現拼圖少了第 500 片時，它必須停下來，向伺服器（寄件人）說：「嘿！第 500 片不見了，<strong>請你重寄一次！</strong>」<p class="text-slate-400 mt-2">在等待重寄的這段時間，你的下載就停滯了。這就是為什麼遺失會導致整體速度變慢。<p class="text-slate-300 font-medium mt-4"><strong>重點：</strong> 封包遺失「本身」不會造成高延遲 (High Ping)。高延遲是 <span class="keyword"data-keyword="bufferbloat">緩衝區膨脹</span> 造成的。</div></div></section><section class="max-w-5xl mx-auto"><h2 class="text-3xl font-bold mb-6 text-center">🚗 <span class="gradient-text">CUBIC 的策略：積極試探直到碰壁</span></h2><div class="card p-6 sm:p-8"><p class="text-lg text-slate-300 leading-relaxed">CUBIC 演算法的座右銘是：<strong>「封包遺失 = 網路壅塞」</strong>。<p class="text-lg text-slate-300 leading-relaxed mt-4">它的策略非常激進，就像一個賽車手：<ol class="list-decimal list-inside text-slate-300 space-y-2 mt-4 pl-4"><li><strong>猛踩油門：</strong> 不斷提高發送封包的速度（增加「壅塞視窗」）。<li><strong>直到打滑 (封包遺失)：</strong> 當它偵測到封包遺失時，它會想：「哇！路太擠了！」<li><strong>猛踩煞車：</strong> 立刻將速度（發送速率）<strong>大幅降低</strong>（通常是砍半）。<li><strong>緩慢加速：</strong> 然後再慢慢地、S形地（CUBIC 曲線）把速度提上來，重複循環。</ol><p class="text-lg text-slate-300 leading-relaxed mt-4"><strong>結果：</strong> 這種策略會產生「鋸齒狀」的網路速度，並且為了「試探」極限，它會刻意填滿緩衝區，這就導致了 <span class="keyword"data-keyword="bufferbloat">緩衝區膨脹</span> (高延遲)。</div></section><section class="max-w-5xl mx-auto"><h2 class="text-3xl font-bold mb-6 text-center">🛰️ <span class="gradient-text">BBR 的策略：建立模型並精準巡航</span></h2><div class="card p-6 sm:p-8"><p class="text-lg text-slate-300 leading-relaxed">BBR 認為 CUBIC 太笨了。BBR 的策略是：<strong>「為什麼要等到出事才反應？我來建立一個網路模型。」</strong><p class="text-lg text-slate-300 leading-relaxed mt-4">BBR 像是一個配備了雷達和 GPS 的智慧巡航系統：<ol class="list-decimal list-inside text-slate-300 space-y-2 mt-4 pl-4"><li><strong>主動測量：</strong> 它會持續測量兩個關鍵數據：<ul class="list-disc list-inside ml-6 mt-1"><li><strong>BtlBw (瓶頸頻寬)：</strong> 這條路最窄的地方有多寬？<li><strong><span class="keyword"data-keyword="rtprop">RTprop</span> (傳播延遲)：</strong> 開過去最少要花多少時間？</ul><li><strong>計算容量：</strong> 它用這兩個數據算出 <span class="keyword"data-keyword="bdp">BDP</span> ( $BtlBw \times RTprop$ )，也就是「這條路最多能容納多少車（封包）」。<li><strong>精準巡航：</strong> BBR 的目標是讓路上的車（在途封包）<strong>剛好等於 BDP</strong>。不多也不少。</ol><p class="text-lg text-slate-300 leading-relaxed mt-4"><strong>結果：</strong> 因為 BBR <strong>刻意不去填滿緩衝區</strong>，它只發送網路剛好能處理的量，所以它能同時達到「高吞吐量」（跑滿速）和「低延遲」（不塞車）。</div></section></div><div class="space-y-16"><section class="max-w-5xl mx-auto"><h2 class="text-3xl font-bold mb-6 text-center">🚫 <span class="gradient-text">CUBIC 的困境：傳統演算法的極限</span></h2><p class="text-lg text-slate-400 text-center mb-8 max-w-3xl mx-auto">傳統如 <span class="keyword"data-keyword="cubic">CUBIC</span> 的演算法基於一個過時的假設：<strong>封包遺失 = 網路壅塞</strong>。這在現代網路中導致了兩大問題：<div class="grid md:grid-cols-2 gap-6"><div class="card p-6"><h3 class="text-xl font-semibold mb-3">🐌 緩衝區膨脹 (Bufferbloat)</h3><p class="text-slate-400">在緩衝區過大的網路（如家用路由器），CUBIC 會不斷填滿緩衝區直到發生遺失，導致<strong>吞吐量看似很高，但延遲（Ping）卻急劇飆升</strong>，使互動式應用幾乎無法使用。</div><div class="card p-6"><h3 class="text-xl font-semibold mb-3">📉 淺緩衝區效能不佳</h3><p class="text-slate-400">在緩衝區極小的高速交換器上，即使是微小的流量突發也會導致封包遺失。CUBIC 會將此誤判為嚴重壅塞，<strong>導致頻寬嚴重利用不足</strong>。</div></div></section><section class="max-w-5xl mx-auto"><h2 class="text-3xl font-bold mb-6 text-center">💡 <span class="gradient-text">BBR 的革新 與 BBRv2 的平衡</span></h2><div class="grid md:grid-cols-2 gap-6"><div class="card p-6 space-y-4"><h3 class="text-xl font-semibold">BBR v1：基於模型的革命</h3><p class="text-slate-400"><span class="keyword"data-keyword="bbr">BBR</span> 拋棄了「遺失」信號，轉而主動為網路建立模型。它持續測量兩個關鍵指標：<ul class="list-disc list-inside text-slate-400 space-y-2"><li><strong>BtlBw (瓶頸頻寬)</strong>：路徑中最窄處的最高速率。<li><strong><span class="keyword"data-keyword="rtprop">RTprop</span> (傳播延遲)</strong>：路徑的最小物理來回時間。</ul><p class="text-slate-400">BBR 的目標是將在途資料量維持在 <span class="keyword"data-keyword="bdp">BDP</span> ( $BtlBw \times RTprop$ ) 附近，從而實現高吞吐與低延遲。</div><div class="card p-6 space-y-4"><h3 class="text-xl font-semibold">BBR v2：學會公平與共存</h3><p class="text-slate-400">BBRv1 雖然強大，但因<strong>完全忽視封包遺失</strong>，在與 CUBIC 流量共存時顯得極具侵略性，會「竊取」所有頻寬。<p class="text-slate-400"><span class="keyword"data-keyword="bbr2">BBRv2</span> (Windows 11 預設) 是一次關鍵的修正。它重新將「遺失」和 <span class="keyword"data-keyword="ecn">ECN</span> 納入模型，使其在偵測到壅塞時會主動降速。<p class="text-slate-300 font-medium"><strong>結論：BBRv2 犧牲了少許極限效能，換取了更優良的網路公民行為，實現了效能與公平性的平衡。</strong></div></div></section><section class="max-w-5xl mx-auto"><h2 class="text-3xl font-bold mb-6 text-center">🚀 <span class="gradient-text">實戰：如何在 Linux 與 Windows 啟用 BBR</span></h2><div class="grid md:grid-cols-2 gap-6"><div class="card p-6"><h3 class="text-xl font-semibold mb-4">🐧 Linux (啟用 BBR v1)</h3><p class="text-slate-400 mb-4">需要核心版本 <strong>4.9 或更高</strong>。<ol class="space-y-4"><li><label class="block text-sm font-medium text-slate-400">1. 檢查核心版本</label><pre class="bg-slate-900 p-3 rounded-md text-slate-300 text-sm overflow-x-auto"><code>uname -r</code></pre><li><label class="block text-sm font-medium text-slate-400">2. 修改 <code>sysctl.conf</code> (永久生效)</label><pre class="bg-slate-900 p-3 rounded-md text-slate-300 text-sm overflow-x-auto"><code>echo "net.core.default_qdisc=fq" >> /etc/sysctl.conf
echo "net.ipv4.tcp_congestion_control=bbr" >> /etc/sysctl.conf</code></pre><p class="text-xs text-slate-500 mt-1"><span class="keyword"data-keyword="fq">fq</span> 排程器是 BBR 的關鍵夥伴，有助於平滑發包。<li><label class="block text-sm font-medium text-slate-400">3. 套用變更</label><pre class="bg-slate-900 p-3 rounded-md text-slate-300 text-sm overflow-x-auto"><code>sysctl -p</code></pre><li><label class="block text-sm font-medium text-slate-400">4. 驗證</label><pre class="bg-slate-900 p-3 rounded-md text-slate-300 text-sm overflow-x-auto"><code>sysctl net.ipv4.tcp_congestion_control</code></pre><p class="text-xs text-slate-500 mt-1">應返回 <code>... = bbr</code>。</ol></div><div class="card p-6"><h3 class="text-xl font-semibold mb-4">💻 Windows 11 (啟用 BBR v2)</h3><p class="text-slate-400 mb-4">需要 <strong>Windows 11 版本 22H2 或更高</strong>。<ol class="space-y-4"><li><label class="block text-sm font-medium text-slate-400">1. 以「系統管理員」身分開啟 PowerShell</label><li><label class="block text-sm font-medium text-slate-400">2. 檢查目前設定 (預設應為 CUBIC)</label><pre class="bg-slate-900 p-3 rounded-md text-slate-300 text-sm overflow-x-auto"><code>Get-NetTCPSetting | Select SettingName,CongestionProvider</code></pre><li><label class="block text-sm font-medium text-slate-400">3. 為所有範本啟用 BBRv2</label><pre class="bg-slate-900 p-3 rounded-md text-slate-300 text-sm overflow-x-auto"><code>netsh int tcp set supplemental Template=Internet CongestionProvider=bbr2
netsh int tcp set supplemental Template=Datacenter CongestionProvider=bbr2
netsh int tcp set supplemental Template=Compat CongestionProvider=bbr2
netsh int tcp set supplemental Template=DatacenterCustom CongestionProvider=bbr2
netsh int tcp set supplemental Template=InternetCustom CongestionProvider=bbr2</code></pre><li><label class="block text-sm font-medium text-slate-400">4. 再次驗證</label><pre class="bg-slate-900 p-3 rounded-md text-slate-300 text-sm overflow-x-auto"><code>Get-NetTCPSetting | Select SettingName,CongestionProvider</code></pre><p class="text-xs text-slate-500 mt-1"><code>CongestionProvider</code> 欄應顯示 <code>BBR2</code>。</ol></div></div></section><section class="max-w-5xl mx-auto"><h2 class="text-3xl font-bold mb-6 text-center">📊 <span class="gradient-text">如何驗證「真的變快了」？</span></h2><p class="text-lg text-slate-400 text-center mb-8 max-w-3xl mx-auto">啟用 BBR 後，你必須進行「啟用前」與「啟用後」的對比測試。<strong>僅憑感覺是不準確的</strong>。你需要一個科學的框架。<div class="card p-6 sm:p-8"><h3 class="text-xl font-semibold mb-4">使用 <span class="keyword"data-keyword="iperf3">iperf3</span> 和 <code>ping</code> 進行實證</h3><div class="mb-6 p-4 border-l-4 border-sky-500 bg-sky-900/30 rounded-r-md"role="alert"><p class="font-medium text-sky-300">💡 延伸閱讀推薦<p class="text-slate-300 mt-1">如果你不熟悉 iperf3 的安裝與使用，這篇文章提供了完整的教學： <a href="https://wellstsai.com/post/iperf3/"target="_blank"rel="noopener noreferrer"class="font-medium text-sky-400 hover:text-sky-300 transition-colors">《安裝並使用 iPerf3 進行網路速度測試》</a></div><div class="space-y-6"><div><h4 class="text-lg font-medium text-sky-400 mb-2">1. 測量吞吐量 (Bandwidth)</h4><p class="text-slate-400 mb-2">使用 <span class="keyword"data-keyword="iperf3">iperf3</span> 工具在客戶端和伺服器之間進行測試。<pre class="bg-slate-900 p-3 rounded-md text-slate-300 text-sm overflow-x-auto"><code># 在伺服器上執行:
iperf3 -s

# 在客戶端上執行 (測試 30 秒):
iperf3 -c &lt;server_ip&gt; -t 30</code></pre><p class="text-slate-400 mt-2"><strong>觀察指標：</strong> 比較前後的 <code>Bandwidth</code> (Mbits/sec)。同時，BBRv2 應顯示<strong>更低的 <code>Retr</code> (重傳) 次數</strong>。</div><div><h4 class="text-lg font-medium text-sky-400 mb-2">2. 測量負載下的延遲 (Bufferbloat)</h4><p class="text-slate-400 mb-2">這 是 BBR 的關鍵優勢。在 <strong><code>iperf3</code> 測試執行期間</strong>，同時在另一個終端機對伺服器執行 <code>ping</code>。<pre class="bg-slate-900 p-3 rounded-md text-slate-300 text-sm overflow-x-auto"><code>ping &lt;server_ip&gt; -t</code></pre><p class="text-slate-400 mt-2"><strong>觀察指標：</strong> 啟用 CUBIC 時，<code>ping</code> 值在傳輸時可能會飆升 (例如 20ms -> 200ms)。啟用 BBR 後，<code>ping</code> 值應<strong>保持接近閒置時的低延遲</strong>。</div></div></div></section><section class="max-w-5xl mx-auto"><h2 class="text-3xl font-bold mb-6 text-center">⚠️ <span class="gradient-text">進階考量：BBR 並非萬靈丹</span></h2><div class="grid md:grid-cols-2 gap-6"><div class="card p-6"><h3 class="text-xl font-semibold mb-3">📶 WiFi 效能異常</h3><p class="text-slate-400">BBR 平滑、穩定的「調步」發包方式，有時會與 WiFi 晶片的「訊框聚合」機制衝突，導致<strong>在 WiFi 環境下的速度反而可能比 CUBIC 更慢</strong>。<p class="text-slate-400 mt-2"><strong>建議：</strong> 如果你的伺服器主要服務 WiFi 客戶端，務必在 WiFi 環境下進行實測。</div><div class="card p-6"><h3 class="text-xl font-semibold mb-3">🎯 BBR 的最佳戰場</h3><p class="text-slate-400">BBR 不是一個「通用升級」，而是一個策略性調整。它在以下情境中表現最為出色：<ul class="list-disc list-inside text-slate-400 space-y-2 mt-3"><li><strong>長胖網路 (LFNs)：</strong>高頻寬、高延遲的跨洲或跨洋傳輸。<li><strong>有損耗的連線：</strong>如衛星、4G/5G 行動網路。<li><strong>低延遲伺服器：</strong>需要在大流量下保持低延遲的 Web 或應用程式伺服器。</ul></div></div></section><section class="max-w-3xl mx-auto text-center"><h2 class="text-3xl font-bold mb-6"><span class="gradient-text">⚖️ 結論：我該換成 BBR 嗎？</span></h2><p class="text-lg text-slate-400 leading-relaxed">這是一個<strong>策略上的取捨</strong>，而非「絕對的升級」。BBR (尤其是 BBRv2) 的設計目標是在「不確定的網際網路」上提供更穩定、低延遲、高吞吐的體驗。<p class="text-lg text-slate-400 leading-relaxed mt-4">在<strong>大多數「網際網路」情境下</strong>（例如，你的伺服器在國外、用戶遍布全球、或你使用 4G/5G 網路），BBRv2 幾乎總能提供比 CUBIC 更平滑、低延遲的體驗。<p class="text-lg text-slate-300 leading-relaxed mt-4">然而，在特定情況下（如「<strong>純 WiFi</strong>」環境或「<strong>超高速內網</strong>」），BBR 的「調步」發包機制有時<strong>可能反而更糟</strong>。<p class="text-lg text-slate-100 font-semibold leading-relaxed mt-4">因此，唯一的答案是：信任，但要驗證。在你的特定環境中進行啟用前後的 <code>iperf3</code> 和 <code>ping</code> 測試，讓數據告訴你答案。</section></div></main><footer class="fixed bottom-0 left-0 right-0 p-4 text-center text-sm z-10"><a href="https://wellstsai.com"target="_blank"rel="noopener noreferrer"class="hover:text-sky-400 transition-colors">Generated by wellstsai.com </a><span class="mx-2">|</span> <span>撰寫日期：2025-10-31</span></footer><script>document.addEventListener("DOMContentLoaded",()=>{window.renderMathInElement&&renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1});const e={bbr:{title:"TCP BBR",desc:"<strong>Bottleneck Bandwidth and Round-trip propagation time</strong><br>由 Google 開發的一種基於模型的壅塞控制演算法。它不依賴封包遺失，而是主動測量網路的「瓶頸頻寬」和「最小延遲」，以實現高吞TP與低延遲。"},bbr2:{title:"TCP BBR v2",desc:"BBR 的第二版，也是 Windows 11 採用的版本。<br><strong>關鍵改進：</strong> BBRv2 重新將「封包遺失」和 ECN 納入考量，使其在壅塞時會主動降速，解決了 BBRv1 對 CUBIC 流量過於霸道和不公平的問題。"},cubic:{title:"CUBIC",desc:"一種「基於遺失」的 TCP 壅塞控制演算法，是 Linux、macOS 和舊版 Windows 的預設演算法。<br>其核心邏輯是「積極探測頻寬直到發生封包遺失，然後迅速降低速率」，這會導致「鋸齒狀」的吞吐量和緩衝區膨脹。"},bufferbloat:{title:"緩衝區膨脹 (Bufferbloat)",desc:"由於網路設備（如路由器）中存在過大的緩衝區，導致封包在佇列中花費過多時間，從而引起<strong>高延遲</strong>的現象。<br>即使網路吞吐量很高，使用者也會感覺到「卡頓」，尤其是在遊戲或視訊通話中。"},rtprop:{title:"RTprop (Round-trip Propagation Time)",desc:"來回傳播時間。<br>指封包在網路路徑上的<strong>最小物理來回時間</strong>，不包含任何在緩衝區中排隊等待的延遲。BBR 會週期性地排空佇列以測量這個值。"},bdp:{title:"BDP (Bandwidth-Delay Product)",desc:"頻寬延遲積。<br>BBR 追求的理想在途資料量。<br><code>BDP = BtlBw × RTprop</code><br> ( $BDP = BtlBw \\times RTprop$ ) <br>BBR 試圖將在途資料量維持在 BDP 附近，以剛好填滿「管線」而不產生佇列。"},fq:{title:"Fair Queue (fq)",desc:"一種封包排程器 (Queue Discipline, qdisc)，是 BBR 的推薦搭配。<br>BBR 是一種「基於調步」的演算法，它需要一個能準確、平滑地按照指定速率發送封包的排程器，而 fq 正是為此設計的。"},ecn:{title:"ECN (Explicit Congestion Notification)",desc:"明確壅塞通知。<br>一種允許路由器在緩衝區「即將」滿時，主動在封包上做標記（而不是直接丟棄封包）的機制，以提前通知傳送端降速。BBRv2 會利用此信號來避免壅塞。"},iperf3:{title:"iperf3",desc:"一個業界標準的網路效能測試工具，用於測量 TCP 和 UDP 的最大吞吐量（頻寬）。<br>它以客戶端-伺服器模式運作，是驗證 BBR 效能是否提升的關鍵工具。"}},t=document.getElementById("tooltip"),n=document.querySelectorAll(".keyword");if(!t)return;const r=n=>{const r=n.target.dataset.keyword,i=e[r];i&&(t.innerHTML=`<h3>${i.title}</h3><p>${i.desc}</p>`,window.renderMathInElement&&renderMathInElement(t,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}),t.style.display="block",o(n))},i=()=>{t.style.display="none",t.innerHTML=""},o=e=>{if("block"!==t.style.display)return;const n=t.getBoundingClientRect(),r=n.width,i=n.height,o=window.innerWidth,d=window.innerHeight,l=window.scrollY,s=e.pageX,a=e.pageY,B=15;let c,p;p=a+B,p-l+i+B>d&&(p=a-i-B),c=s+B,c+r+B>o&&(c=s-r-B,c<B&&(c=B));const g=o-30;t.style.maxWidth=`${g}px`,t.style.left=`${c}px`,t.style.top=`${p}px`};n.forEach(e=>{e.addEventListener("mouseenter",r),e.addEventListener("mouseleave",i),e.addEventListener("mousemove",o)}),document.addEventListener("mousemove",o)})</script>