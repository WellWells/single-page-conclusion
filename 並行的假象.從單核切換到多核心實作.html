<!doctypehtml><html lang="zh-Hant"><meta name="twitter:image"content="https://wellstsai.com/single-page-conclusion/%E4%B8%A6%E8%A1%8C%E7%9A%84%E5%81%87%E8%B1%A1.%E5%BE%9E%E5%96%AE%E6%A0%B8%E5%88%87%E6%8F%9B%E5%88%B0%E5%A4%9A%E6%A0%B8%E5%BF%83%E5%AF%A6%E4%BD%9C.png"><meta name="twitter:description"content="揭示並行的假象：從單核快速切換到多核心實作、問題根源與解決方案，說明作業系統排程、技術演進及並行／平行在現代應用中的差異與影響與實例。"><meta name="twitter:title"content="並行的假象：從單核切換到多核心實作"><meta name="twitter:card"content="summary_large_image"><meta property="og:type"content="article"><meta property="og:site_name"content="WellWells"><meta property="og:image"content="https://wellstsai.com/single-page-conclusion/%E4%B8%A6%E8%A1%8C%E7%9A%84%E5%81%87%E8%B1%A1.%E5%BE%9E%E5%96%AE%E6%A0%B8%E5%88%87%E6%8F%9B%E5%88%B0%E5%A4%9A%E6%A0%B8%E5%BF%83%E5%AF%A6%E4%BD%9C.png"><meta property="og:url"content="https://wellstsai.com/single-page-conclusion/%E4%B8%A6%E8%A1%8C%E7%9A%84%E5%81%87%E8%B1%A1.%E5%BE%9E%E5%96%AE%E6%A0%B8%E5%88%87%E6%8F%9B%E5%88%B0%E5%A4%9A%E6%A0%B8%E5%BF%83%E5%AF%A6%E4%BD%9C.html"><meta property="og:description"content="揭示並行的假象：從單核快速切換到多核心實作、問題根源與解決方案，說明作業系統排程、技術演進及並行／平行在現代應用中的差異與影響與實例。"><meta property="og:title"content="並行的假象：從單核切換到多核心實作"><meta name="description"content="揭示並行的假象：從單核快速切換到多核心實作、問題根源與解決方案，說明作業系統排程、技術演進及並行／平行在現代應用中的差異與影響與實例。"><meta charset="UTF-8"><meta name="viewport"content="width=device-width,initial-scale=1"><title>並行的假象：從單核切換到多核心實作</title><script src="https://cdn.tailwindcss.com"></script><link rel="preconnect"href="https://fonts.googleapis.com"><link rel="preconnect"href="https://fonts.gstatic.com"crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap"rel="stylesheet"><style>body{font-family:'Noto Sans TC',sans-serif;background-color:#f8f9fa;color:#343a40}.active-nav{color:#4f46e5;font-weight:700}.nav-link{transition:color .3s;color:#6b7280}.nav-link:hover{color:#3730a3}.card{background-color:#fff;border-radius:.75rem;box-shadow:0 4px 6px -1px rgb(0 0 0 / .1),0 2px 4px -2px rgb(0 0 0 / .1);transition:transform .3s,box-shadow .3s}.card:hover{transform:translateY(-5px);box-shadow:0 10px 15px -3px rgb(0 0 0 / .1),0 4px 6px -2px rgb(0 0 0 / .1)}.btn-primary{background-color:#4f46e5;color:#fff;transition:background-color .3s}.btn-primary:hover{background-color:#3730a3}.keyword{color:#4f46e5;font-weight:600;cursor:pointer;transition:all .2s ease-in-out;padding:2px 4px;border-radius:4px}.keyword:hover{background-color:#e0e7ff;transform:scale(1.05)}#modal-backdrop.hidden{display:none}#modal-panel{transition:opacity .3s ease-out,transform .3s ease-out}#modal-backdrop:not(.hidden) #modal-panel{opacity:1;transform:scale(1)}#modal-backdrop.hidden #modal-panel{opacity:0;transform:scale(.95)}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-JKC4KZLT26"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JKC4KZLT26")</script><body class="antialiased"><header class="bg-white/80 backdrop-blur-md sticky top-0 z-50 shadow-sm"><nav class="container mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center"><h1 class="text-xl font-bold text-gray-800">並行的假象：從單核切換到多核心實作</h1><div class="hidden md:flex space-x-8"><a href="#illusion"class="nav-link active-nav">並行假象</a> <a href="#problem"class="nav-link">問題根源</a> <a href="#solution"class="nav-link">解決方案</a> <a href="#evolution"class="nav-link">技術演進</a> <a href="#modern"class="nav-link">現代應用</a></div><div class="md:hidden"><select id="mobile-nav"class="border rounded-md p-2 bg-white"><option value="#illusion">並行假象<option value="#problem">問題根源<option value="#solution">解決方案<option value="#evolution">技術演進<option value="#modern">現代應用</select></div></nav></header><main class="container mx-auto px-4 sm:px-6 lg:px-8 py-8 md:py-12"><section id="illusion"class="min-h-[80vh] flex flex-col justify-center items-center py-16"><div class="grid md:grid-cols-2 gap-16 items-center w-full"><div class="text-center md:text-left"><h2 class="text-4xl md:text-5xl font-bold text-gray-900 mb-4 leading-tight">並行不是你所想的那樣</h2><p class="text-lg text-gray-600">您是否想過，為何只有一顆<span class="keyword"data-term="CPU">CPU</span>的電腦，卻能同時執行數千個程式？這一切都歸功於「<span class="keyword"data-term="Concurrency">並行</span>」(Concurrency) 技術，它創造了一種強大的「同時執行」的假象。</div><div class="w-full p-6 card"><h3 class="text-xl font-semibold mb-2 text-center">單核心CPU的多工處理模擬</h3><p class="text-sm text-gray-500 mb-4 text-center">觀察CPU如何在不同程式間快速切換，快到讓您以為它們是同時進行的。<div class="flex justify-center mb-4"><button id="animation-toggle"class="bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-lg transition-colors duration-200 font-medium">暫停動畫</button></div><div id="animation-container"class="relative bg-gradient-to-br from-gray-50 to-gray-100 rounded-xl p-6 h-64 overflow-hidden"><div class="absolute inset-0 bg-grid-pattern opacity-10"></div><style>.bg-grid-pattern{background-image:linear-gradient(to right,#4f46e5 1px,transparent 1px),linear-gradient(to bottom,#4f46e5 1px,transparent 1px);background-size:20px 20px}.connection-line{position:absolute;height:3px;background:linear-gradient(to right,#4f46e5,#06b6d4);border-radius:2px;opacity:0;transition:all .4s ease-in-out;z-index:5}.connection-line.active{opacity:1;box-shadow:0 0 10px rgba(79,70,229,.5)}.cpu-pulse{animation:pulse .6s ease-in-out}@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.1)}100%{transform:scale(1)}}.process-glow{box-shadow:0 0 20px rgba(79,70,229,.6);transform:scale(1.05)}</style><div class="absolute left-8 top-1/2 transform -translate-y-1/2 z-10"><div id="cpu-box"class="w-20 h-20 bg-gradient-to-br from-indigo-500 to-indigo-600 rounded-full flex flex-col justify-center items-center text-white font-bold shadow-xl border-4 border-white relative"><span class="text-sm">CPU</span> <span class="text-xs font-normal opacity-90">核心</span><div id="cpu-indicator"class="absolute -top-1 -right-1 w-4 h-4 bg-green-400 rounded-full border-2 border-white"></div></div></div><div class="absolute right-8 top-1/2 transform -translate-y-1/2 space-y-3 z-10"><div id="proc-a"class="w-40 text-center px-4 py-3 bg-white rounded-lg border-2 border-gray-200 transition-all duration-300 cursor-default shadow-sm relative"><span class="font-medium text-gray-700">程式 A</span><div class="process-status absolute top-1 right-2 w-2 h-2 bg-gray-300 rounded-full"></div></div><div id="proc-b"class="w-40 text-center px-4 py-3 bg-white rounded-lg border-2 border-gray-200 transition-all duration-300 cursor-default shadow-sm relative"><span class="font-medium text-gray-700">程式 B</span><div class="process-status absolute top-1 right-2 w-2 h-2 bg-gray-300 rounded-full"></div></div><div id="proc-c"class="w-40 text-center px-4 py-3 bg-white rounded-lg border-2 border-gray-200 transition-all duration-300 cursor-default shadow-sm relative"><span class="font-medium text-gray-700">程式 C</span><div class="process-status absolute top-1 right-2 w-2 h-2 bg-gray-300 rounded-full"></div></div></div><div id="connection-line-a"class="connection-line"></div><div id="connection-line-b"class="connection-line"></div><div id="connection-line-c"class="connection-line"></div><div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-white px-4 py-2 rounded-lg shadow-lg border"><div class="text-sm text-gray-600">當前執行：</div><div id="current-executing"class="font-bold text-indigo-600">準備開始...</div></div></div></div></div></section><section id="problem"class="py-16"><h2 class="text-3xl font-bold text-center mb-2">問題的根源：昂貴的閒置時間</h2><p class="max-w-3xl mx-auto text-center text-gray-600 mb-12">在個人電腦普及前，<span class="keyword"data-term="Mainframe">大型主機</span> (Mainframe) 極其昂貴。然而，在執行一個程式的過程中，有大量的準備時間，例如從磁帶載入編譯器或等待使用者輸入，這段期間<span class="keyword"data-term="CPU">CPU</span>完全處於閒置狀態，造成巨大的資源浪費。<div class="card p-6 md:p-8"><h3 class="text-xl font-semibold mb-6 text-center">早期電腦執行程式的繁瑣流程</h3><div id="mainframe-flow"class="flex flex-col md:flex-row justify-center items-center space-y-4 md:space-y-0 md:space-x-2 text-center"><div class="flow-step"data-desc="程式設計師手動掛載存有編譯器的磁帶。">載入編譯器</div><div class="arrow">➡️</div><div class="flow-step idle"data-desc="CPU等待磁帶讀取完成，此時完全閒置。">CPU 閒置</div><div class="arrow">➡️</div><div class="flow-step"data-desc="程式設計師輸入原始碼，進行編譯。">編譯成組合語言</div><div class="arrow">➡️</div><div class="flow-step"data-desc="再次掛載存有組譯器的磁帶。">載入組譯器</div><div class="arrow">➡️</div><div class="flow-step idle"data-desc="CPU再次等待磁帶讀取，再次閒置。">CPU 閒置</div><div class="arrow">➡️</div><div class="flow-step"data-desc="將組合語言轉為電腦可執行的機器碼。">組譯成機器碼</div><div class="arrow">➡️</div><div class="flow-step final"data-desc="程式終於可以開始執行。">執行程式</div></div><p id="flow-desc"class="text-center mt-6 text-indigo-600 font-medium h-10">將滑鼠懸停在步驟上查看說明</p><style>.flow-step{padding:.75rem 1rem;border-radius:.5rem;border:2px solid #e5e7eb;background-color:#f9fafb;font-weight:500;cursor:pointer;transition:all .2s}.flow-step.idle{border-color:#fca5a5;background-color:#fef2f2;color:#b91c1c}.flow-step.final{border-color:#86efac;background-color:#f0fdf4;color:#15803d}.arrow{font-size:1.5rem;color:#9ca3af;margin:0 .5rem}@media (max-width:767px){.arrow{transform:rotate(90deg);margin:.5rem 0}}</style></div></section><section id="solution"class="py-16 px-8 bg-white rounded-lg"><h2 class="text-3xl font-bold text-center mb-2">解決方案：作業系統的巧妙調度</h2><p class="max-w-3xl mx-auto text-center text-gray-600 mb-12">為了解決CPU閒置問題，<span class="keyword"data-term="Time-sharing">分時</span> (Time-sharing) <span class="keyword"data-term="Operating System">作業系統</span>誕生了。作業系統扮演著交通警察的角色，透過精準控制CPU中的「<span class="keyword"data-term="Address Register">位址暫存器</span>」，讓CPU在不同程式之間來回跳轉執行，這就是所謂的「<span class="keyword"data-term="Context Switching">情境切換</span>」(Context Switching)。<div class="grid md:grid-cols-2 gap-8 items-center"><div class="card p-6"><h3 class="text-xl font-semibold mb-4">CPU排程模擬器</h3><p class="text-sm text-gray-500 mb-6">CPU內部有一個「位址暫存器」，指向下一個要執行的指令記憶體位址。作業系統的「排程器」透過改變這個暫存器的值，來決定下一個要執行哪個程式。<div class="bg-gray-100 p-4 rounded-lg"><div class="flex items-center mb-4"><span class="font-bold w-40">位址暫存器:</span> <span id="address-register"class="font-mono bg-white p-2 rounded w-full text-center">0x0000</span></div><div class="flex items-center"><span class="font-bold w-40">目前執行:</span> <span id="current-process"class="bg-white p-2 rounded w-full text-center font-semibold text-indigo-700">無</span></div></div><div class="mt-6 flex justify-center space-x-2"><button class="scheduler-btn"data-proc="A"data-addr="0x1A40">執行程式 A</button> <button class="scheduler-btn"data-proc="B"data-addr="0x3B18">執行程式 B</button> <button class="scheduler-btn"data-proc="OS"data-addr="0x00A1">交還給作業系統</button></div><style>.scheduler-btn{padding:.5rem 1rem;border-radius:.375rem;background-color:#eef2ff;color:#4338ca;font-weight:500;transition:all .2s;border:1px solid #c7d2fe}.scheduler-btn:hover{background-color:#e0e7ff}</style></div><div class="text-gray-700 space-y-4"><h3 class="text-xl font-semibold">作業系統如何奪回控制權？</h3><p>程式不能無限制地執行，必須在某些時刻將控制權交還給作業系統。這是透過「<span class="keyword"data-term="Interruptions">中斷</span>」(Interruptions) 機制實現的。<p>當程式需要執行敏感操作，如讀取檔案或請求記憶體時（稱為<span class="keyword"data-term="I/O operations">I/O操作</span>），它會觸發一個中斷信號。CPU收到信號後，會暫停目前工作，儲存當前狀態，然後跳到作業系統的專屬記憶體區域執行「中斷服務常式」。<p>此時，作業系統便重新掌握了CPU的控制權，它可以處理程式的請求，並決定接下來要執行哪個程式。這個循環不斷重複，構成了多工處理的基礎。</div></div></section><section id="evolution"class="py-16"><h2 class="text-3xl font-bold text-center mb-2">技術的演進：從合作到強制</h2><p class="max-w-3xl mx-auto text-center text-gray-600 mb-12">早期的排程方式依賴程式「自願」交還CPU，但如果遇到惡意或有bug的程式（例如無限迴圈），系統就會完全卡死。為了安全與穩定，現代作業系統採用了更強制的手段。<div class="grid md:grid-cols-2 gap-8"><div class="card p-8 flex flex-col items-center text-center"><h3 class="font-bold text-xl text-amber-600 mb-4">協同式排程</h3><p class="text-gray-500 mb-6 text-sm">Cooperative Scheduling<div class="space-y-4"><div class="flex items-start"><span class="mr-3 text-lg">🤝</span><div><strong class="text-gray-800">控制權：</strong>程式主導，自願放棄。</div></div><div class="flex items-start"><span class="mr-3 text-lg">⚠️</span><div><strong class="text-gray-800">安全性：</strong>低，易被單一程式綁架。</div></div><div class="flex items-start"><span class="mr-3 text-lg">💻</span><div><strong class="text-gray-800">代表：</strong>早期 Windows (3.1及以前)。</div></div></div></div><div class="card p-8 flex flex-col items-center text-center"><h3 class="font-bold text-xl text-teal-600 mb-4">先佔式排程</h3><p class="text-gray-500 mb-6 text-sm">Preemptive Scheduling<div class="space-y-4"><div class="flex items-start"><span class="mr-3 text-lg">👑</span><div><strong class="text-gray-800">控制權：</strong>系統主導，強制收回。</div></div><div class="flex items-start"><span class="mr-3 text-lg">🛡️</span><div><strong class="text-gray-800">安全性：</strong>高，穩定且公平。</div></div><div class="flex items-start"><span class="mr-3 text-lg">🚀</span><div><strong class="text-gray-800">代表：</strong>現代作業系統 (Windows 95+, Linux)。</div></div></div></div></div></section><section id="modern"class="py-16 px-8 bg-indigo-50 rounded-lg"><h2 class="text-3xl font-bold text-center mb-2">現代應用：並行 (Concurrency) vs 平行 (Parallelism)</h2><p class="max-w-3xl mx-auto text-center text-gray-600 mb-12">隨著<span class="keyword"data-term="Multi-core">多核心</span>CPU的出現，我們終於可以實現真正的「<span class="keyword"data-term="Parallelism">平行處理</span>」。但這不代表<span class="keyword"data-term="Concurrency">並行</span>就過時了，事實上，兩者在現代電腦中協同工作，以最高效率管理無數的任務。<div class="grid md:grid-cols-2 gap-8 items-center"><div class="card p-6 text-center"><h3 class="text-xl font-semibold mb-4">多核心處理模型</h3><p class="text-sm text-gray-500 mb-6">在多核心系統中，排程器可以將不同程式分配到不同核心上，實現真正的同時執行。<div class="flex justify-center space-x-8"><div><div class="w-24 h-24 bg-green-500 rounded-lg flex justify-center items-center text-white font-bold text-lg shadow-md mb-2">核心 1</div><div id="core1-task"class="font-mono text-sm p-2 bg-gray-200 rounded">閒置</div></div><div><div class="w-24 h-24 bg-green-500 rounded-lg flex justify-center items-center text-white font-bold text-lg shadow-md mb-2">核心 2</div><div id="core2-task"class="font-mono text-sm p-2 bg-gray-200 rounded">閒置</div></div></div><div class="mt-6 flex justify-center space-x-2"><button id="parallel-btn"class="btn-primary rounded-md px-4 py-2 text-sm">模擬平行</button> <button id="concurrent-parallel-btn"class="btn-primary rounded-md px-4 py-2 text-sm">模擬並行+平行</button></div></div><div class="text-gray-700 space-y-4"><div class="p-4 bg-white rounded-lg shadow-sm"><h4 class="font-bold text-lg text-indigo-700">並行 (Concurrency)</h4><p>是關於「處理」很多事情。它是一種結構，一種管理多個任務的方式，即使只有一個執行單元，也能透過快速切換來推進所有任務。</div><div class="p-4 bg-white rounded-lg shadow-sm"><h4 class="font-bold text-lg text-green-700">平行 (Parallelism)</h4><p>是關於「執行」很多事情。它需要多個執行單元（如多核心），讓多個任務在物理上真正同時發生。</div><div class="p-6 bg-gray-800 text-white rounded-lg shadow-lg text-center"><p class="text-lg italic">"Concurrency is about dealing with lots of things at once.<br>Parallelism is about doing lots of things at once."<p class="text-sm mt-2">並行是關於一次處理很多事，而平行是關於一次做很多事。</div></div></div></section></main><footer class="text-center py-8 bg-gray-100 mt-12"><a href="https://wellstsai.com"target="_blank"rel="noopener noreferrer"class="text-gray-600 hover:text-indigo-600 transition-colors">Generated by wellstsai.com</a><p class="text-gray-500 text-sm mt-2">撰寫日期：2025年9月10日</footer><div id="modal-backdrop"class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center p-4 z-50"><div id="modal-panel"class="w-full max-w-2xl bg-white/60 backdrop-blur-lg border border-white/20 rounded-xl shadow-2xl p-6 opacity-0 transform scale-95"><div class="flex justify-between items-center mb-4"><h3 id="modal-title"class="text-2xl font-bold text-gray-800"></h3><button id="modal-close-btn"class="text-gray-500 hover:text-gray-800 transition-colors">&times;</button></div><div id="modal-content"class="text-gray-700 leading-relaxed"></div></div></div><script>document.addEventListener("DOMContentLoaded",()=>{const e=document.getElementById("cpu-box"),t=document.getElementById("cpu-indicator"),n=document.getElementById("current-executing"),o=document.getElementById("animation-toggle"),d=[{id:"proc-a",name:"程式 A",lineId:"connection-line-a"},{id:"proc-b",name:"程式 B",lineId:"connection-line-b"},{id:"proc-c",name:"程式 C",lineId:"connection-line-c"}];let l,c,r=0,s=!0;function i(){const t=document.getElementById("animation-container").getBoundingClientRect(),n=e.getBoundingClientRect(),o=n.left-t.left+n.width/2,l=n.top-t.top+n.height/2;d.forEach((e,n)=>{const d=document.getElementById(e.id),c=document.getElementById(e.lineId),r=d.getBoundingClientRect(),s=r.left-t.left+r.width/2,i=r.top-t.top+r.height/2,a=s-o,m=i-l,u=Math.sqrt(a*a+m*m),g=180*Math.atan2(m,a)/Math.PI;c.style.width=u+"px",c.style.left=o+"px",c.style.top=l+"px",c.style.transform=`rotate(${g}deg)`,c.style.transformOrigin="0 50%"})}function a(){d.forEach(e=>{const t=document.getElementById(e.id),n=t.querySelector(".process-status"),o=document.getElementById(e.lineId);t.classList.remove("process-glow"),t.style.borderColor="#e5e7eb",t.style.backgroundColor="white",n.style.backgroundColor="#d1d5db",o.classList.remove("active")})}function m(){s&&(a(),function(o){const l=d[o],c=document.getElementById(l.id),r=c.querySelector(".process-status"),s=document.getElementById(l.lineId);c.classList.add("process-glow"),c.style.borderColor="#4f46e5",c.style.backgroundColor="#eef2ff",r.style.backgroundColor="#10b981",s.classList.add("active"),n.textContent=l.name,e.classList.add("cpu-pulse"),t.style.backgroundColor="#10b981",setTimeout(()=>{e.classList.remove("cpu-pulse")},600)}(r),r=(r+1)%d.length)}o.addEventListener("click",()=>{s?(s=!1,clearInterval(l),a(),n.textContent="動畫已暫停",t.style.backgroundColor="#f59e0b",o.textContent="開始動畫",o.classList.remove("bg-indigo-500","hover:bg-indigo-600"),o.classList.add("bg-green-500","hover:bg-green-600")):(s=!0,l=setInterval(m,1200),o.textContent="暫停動畫",o.classList.remove("bg-green-500","hover:bg-green-600"),o.classList.add("bg-indigo-500","hover:bg-indigo-600"))}),i(),a(),n.textContent="準備開始...",l=setInterval(m,1200),window.addEventListener("resize",function(){clearTimeout(c),c=setTimeout(()=>{i()},250)});const u=document.querySelectorAll(".flow-step"),g=document.getElementById("flow-desc");u.forEach(e=>{e.addEventListener("mouseenter",()=>{g.textContent=e.dataset.desc}),e.addEventListener("mouseleave",()=>{g.textContent="將滑鼠懸停在步驟上查看說明"})});const y=document.getElementById("address-register"),f=document.getElementById("current-process");document.querySelectorAll(".scheduler-btn").forEach(e=>{e.addEventListener("click",()=>{y.textContent=e.dataset.addr,f.textContent=`程式 ${e.dataset.proc}`,"OS"===e.dataset.proc&&(f.textContent="作業系統")})});const v=document.getElementById("core1-task"),C=document.getElementById("core2-task");let E;document.getElementById("parallel-btn").addEventListener("click",()=>{clearInterval(E),v.textContent="執行程式 A",C.textContent="執行程式 B"}),document.getElementById("concurrent-parallel-btn").addEventListener("click",()=>{clearInterval(E);let e=!0;v.textContent="執行程式 A",C.textContent="執行程式 B",E=setInterval(()=>{e?(v.textContent="執行程式 C",C.textContent="執行程式 D"):(v.textContent="執行程式 A",C.textContent="執行程式 B"),e=!e},1500)});const I={Concurrency:{title:"並行 (Concurrency)",def:"一種系統架構，允許同時處理多個任務。即使只有一個處理核心，也能透過在任務間快速切換，讓所有任務都能取得進展，創造出「同時執行」的假象。"},CPU:{title:"CPU (中央處理單元)",def:"中央處理單元（Central Processing Unit），是電腦的主要處理部件，負責解釋和執行程式指令。常被稱為電腦的大腦。"},Mainframe:{title:"大型主機 (Mainframe)",def:"是早期功能強大、體積龐大且價格昂貴的電腦，通常由大型組織用於關鍵任務的運算，例如普查、工業統計和金融交易處理。"},"Time-sharing":{title:"分時 (Time-sharing)",def:"一種允許多個使用者透過不同終端同時存取單一電腦資源的技術。作業系統會將CPU時間分割成微小的「時間片」，輪流分配給各個使用者。"},"Operating System":{title:"作業系統 (Operating System)",def:"是管理電腦硬體與軟體資源的系統軟體。它作為使用者和電腦硬體之間的中介，負責行程管理、記憶體管理、檔案系統等核心功能。"},"Address Register":{title:"位址暫存器 (Address Register)",def:"CPU內部的一種特殊暫存器，用於儲存下一個要從記憶體中讀取或寫入的指令或資料的位址。作業系統透過控制它來切換不同的程式。"},"Context Switching":{title:"情境切換 (Context Switching)",def:"指CPU從一個正在執行的行程（Process）或執行緒（Thread）切換到另一個行程的過程。這個過程需要儲存目前行程的狀態，並載入新行程的狀態，是實現多工處理的核心機制，但本身會消耗一定的系統資源。"},Interruptions:{title:"中斷 (Interruptions)",def:"是硬體或軟體向CPU發出的一個信號，要求CPU暫停當前的執行緒，轉而去處理更重要的事件。這是作業系統得以從應用程式手中奪回CPU控制權的主要方式。"},"I/O operations":{title:"I/O操作 (Input/Output)",def:"指電腦與外部世界（如硬碟、網路、鍵盤、顯示器）之間進行資料交換的過程。I/O操作通常比CPU運算慢得多，是觸發作業系統排程的常見時機。"},Parallelism:{title:"平行處理 (Parallelism)",def:"指在擁有多個處理單元（例如多核心處理器）的系統上，真正地同時執行多個任務或一個任務的多個部分。它強調的是「同時做」，而並行則強調「同時管理」。"},"Multi-core":{title:"多核心 (Multi-core)",def:"指在單一晶片上整合兩個或更多個獨立的處理核心（Core）。每個核心都可以獨立執行程式指令，從而實現真正的平行處理，大幅提升電腦的運算能力。"}},h=document.getElementById("modal-backdrop"),p=document.getElementById("modal-title"),b=document.getElementById("modal-content"),B=()=>{h.classList.add("hidden"),document.body.style.overflow=""};document.querySelectorAll(".keyword").forEach(e=>{e.addEventListener("click",t=>{var n;t.stopPropagation(),n=e.dataset.term,I[n]&&(p.textContent=I[n].title,b.textContent=I[n].def,h.classList.remove("hidden"),document.body.style.overflow="hidden")})}),document.getElementById("modal-close-btn").addEventListener("click",B),h.addEventListener("click",e=>{e.target===h&&B()}),document.addEventListener("keydown",e=>{"Escape"!==e.key||h.classList.contains("hidden")||B()}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault(),document.querySelector(this.getAttribute("href")).scrollIntoView({behavior:"smooth"})})}),document.getElementById("mobile-nav").addEventListener("change",function(e){const t=e.target.value;document.querySelector(t).scrollIntoView({behavior:"smooth"})});const L=document.querySelectorAll("section"),x=document.querySelectorAll(".nav-link");window.addEventListener("scroll",()=>{let e="";L.forEach(t=>{const n=t.offsetTop;pageYOffset>=n-60&&(e=t.getAttribute("id"))}),x.forEach(t=>{t.classList.remove("active-nav"),t.getAttribute("href").includes(e)&&t.classList.add("active-nav")});const t=document.getElementById("mobile-nav");e&&t.value!==`#${e}`&&(t.value=`#${e}`)})})</script>