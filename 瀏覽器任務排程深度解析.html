<!doctypehtml><html lang="zh-Hant"><meta name="twitter:image"content="https://wellstsai.com/single-page-conclusion/%E7%80%8F%E8%A6%BD%E5%99%A8%E4%BB%BB%E5%8B%99%E6%8E%92%E7%A8%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.png"><meta name="twitter:description"content="說明瀏覽器計時器節流及 setTimeout(0) 不可靠之處。首選 scheduler.postTask，不支援時以 MessageChannel 作為 fallback，最後才用 setTimeout。附上 nextTask 實作與劣化保護，確保排程順序與穩定性。"><meta name="twitter:title"content="瀏覽器任務排程深度解析"><meta name="twitter:card"content="summary_large_image"><meta property="og:type"content="article"><meta property="og:site_name"content="WellWells"><meta property="og:image"content="https://wellstsai.com/single-page-conclusion/%E7%80%8F%E8%A6%BD%E5%99%A8%E4%BB%BB%E5%8B%99%E6%8E%92%E7%A8%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.png"><meta property="og:url"content="https://wellstsai.com/single-page-conclusion/%E7%80%8F%E8%A6%BD%E5%99%A8%E4%BB%BB%E5%8B%99%E6%8E%92%E7%A8%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.html"><meta property="og:description"content="說明瀏覽器計時器節流及 setTimeout(0) 不可靠之處。首選 scheduler.postTask，不支援時以 MessageChannel 作為 fallback，最後才用 setTimeout。附上 nextTask 實作與劣化保護，確保排程順序與穩定性。"><meta property="og:title"content="瀏覽器任務排程深度解析"><meta name="description"content="說明瀏覽器計時器節流及 setTimeout(0) 不可靠之處。首選 scheduler.postTask，不支援時以 MessageChannel 作為 fallback，最後才用 setTimeout。附上 nextTask 實作與劣化保護，確保排程順序與穩定性。"><meta charset="UTF-8"><meta name="viewport"content="width=device-width,initial-scale=1"><title>瀏覽器任務排程深度解析</title><script src="https://cdn.tailwindcss.com"></script><link rel="preconnect"href="https://fonts.googleapis.com"><link rel="preconnect"href="https://fonts.gstatic.com"crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap"rel="stylesheet"><link rel="stylesheet"href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><style>body{font-family:Inter,'Noto Sans TC',sans-serif;background-color:#fdfbf8;color:#333}#main-content.blurred{filter:blur(5px);transition:filter .3s ease-in-out}.warm-neutral-bg{background-color:#fdfbf8}.warm-neutral-card{background-color:#fff}.warm-neutral-text-primary{color:#2a2a2a}.warm-neutral-text-secondary{color:#5a5a5a}.warm-neutral-accent{color:#4a90e2}.warm-neutral-accent-bg{background-color:#4a90e2}.warm-neutral-accent-border{border-color:#4a90e2}.btn-primary{transition:all .2s ease-in-out}.btn-primary:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(74,144,226,.2)}.tab-active{border-bottom:2px solid #4a90e2;color:#4a90e2;font-weight:600}.log-entry{opacity:0;transform:translateY(10px);animation:fadeIn .5s ease forwards}@keyframes fadeIn{to{opacity:1;transform:translateY(0)}}.code-block{background-color:#282c34;border-radius:.5rem;position:relative;overflow-x:auto}.code-block pre{padding:1.25rem}.copy-btn{position:absolute;top:.75rem;right:.75rem;background-color:#44475a;color:#f8f8f2;border:none;padding:.25rem .6rem;border-radius:.25rem;cursor:pointer;font-size:.8rem;transition:background-color .2s;z-index:10}.copy-btn:hover{background-color:#6272a4}.keyword-interactive{color:#4a90e2;font-weight:500;cursor:pointer;transition:all .2s ease-in-out;padding:2px 4px;margin:-2px -4px;border-radius:4px}.keyword-interactive:hover{background-color:rgba(74,144,226,.1);transform:scale(1.05)}.modal-enter{animation:modal-enter .3s ease-out forwards}.modal-leave{animation:modal-leave .3s ease-in forwards}@keyframes modal-enter{from{opacity:0;transform:scale(.95)}to{opacity:1;transform:scale(1)}}@keyframes modal-leave{from{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.95)}}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-JKC4KZLT26"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JKC4KZLT26")</script><body class="warm-neutral-bg"><div id="main-content"class="container mx-auto px-4 py-8 md:py-12 max-w-5xl transition-filter duration-300"><header class="text-center mb-12"><h1 class="text-4xl md:text-5xl font-bold warm-neutral-text-primary mb-2">瀏覽器任務排程深度解析</h1><p class="text-lg warm-neutral-text-secondary">為何 `setTimeout(0)` 不可靠，以及如何選擇現代且穩健的替代方案</header><main class="space-y-16"><section id="summary"><div class="warm-neutral-card p-6 md:p-8 rounded-xl shadow-sm border border-gray-200"><h2 class="text-2xl font-bold warm-neutral-text-primary mb-4 flex items-center"><svg class="w-6 h-6 mr-3 warm-neutral-accent"fill="none"stroke="currentColor"viewBox="0 0 24 24"xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round"stroke-linejoin="round"stroke-width="2"d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg> 核心結論（1分鐘速覽）</h2><p class="warm-neutral-text-secondary mb-6">本頁將深入探討瀏覽器對計時器的節流機制，並提供具體的程式碼實踐。以下是關鍵摘要，幫助您快速掌握核心概念，並了解為何需要更精確的任務排程 API。<ul class="space-y-3 warm-neutral-text-primary list-inside"><li class="flex items-start"><span class="warm-neutral-accent font-bold mr-3">▶</span><span>瀏覽器為保護系統資源與使用者體驗，會對 <span class="keyword-interactive"data-keyword="setTimeout">setTimeout</span> 進行<strong class="font-semibold"><span class="keyword-interactive"data-keyword="clamping">節流（clamping）</span></strong>，使其最小延遲通常不低於 4ms。</span><li class="flex items-start"><span class="warm-neutral-accent font-bold mr-3">▶</span><span>若需要在 <span class="keyword-interactive"data-keyword="microtasks">microtasks</span> 完成後「立即」執行下一個 task，應優先使用 <span class="keyword-interactive"data-keyword="scheduler.postTask">scheduler.postTask</span>。</span><li class="flex items-start"><span class="warm-neutral-accent font-bold mr-3">▶</span><span>在不支援 <code class="bg-gray-100 px-1.5 py-0.5 rounded">scheduler</code> 的環境，重用單一 <span class="keyword-interactive"data-keyword="MessageChannel">MessageChannel</span> 是高效且能保證順序的 fallback 選擇。</span><li class="flex items-start"><span class="warm-neutral-accent font-bold mr-3">▶</span><span>為應對 Safari 等瀏覽器的實作差異，穩健的 library 應實作包含<strong class="font-semibold">劣化保護</strong>與可配置的 fallback 策略。</span></ul></div></section><section id="problem-analysis"><h2 class="text-3xl font-bold text-center warm-neutral-text-primary mb-8">問題解析：為何 `setTimeout` 會被節流？</h2><p class="text-center max-w-3xl mx-auto warm-neutral-text-secondary mb-10">瀏覽器的主要職責之一是作為「使用者代理」，在網頁功能與系統資源之間取得平衡。過於頻繁的計時器會持續喚醒 CPU，增加耗電，並可能導致介面卡頓。因此，瀏覽器透過「<span class="keyword-interactive"data-keyword="clamping">節流</span>」機制來限制這種行為，保護使用者裝置與體驗。<div class="grid md:grid-cols-2 gap-8"><div class="warm-neutral-card p-6 rounded-xl shadow-sm border border-gray-200"><h3 class="text-xl font-semibold warm-neutral-text-primary mb-3">Clamping 行為詳解</h3><p class="warm-neutral-text-secondary">HTML 規格定義，在特定情境下，計時器的最小延遲會被「<span class="keyword-interactive"data-keyword="clamping">夾住（clamp）</span>」在一個較高的值（通常是 4ms）。這個值在背景分頁、省電模式或低更新率螢幕上會更高。這意味著 <code class="bg-gray-100 px-1.5 py-0.5 rounded">setTimeout(fn, 0)</code> 並不保證零延遲。</div><div class="warm-neutral-card p-6 rounded-xl shadow-sm border border-gray-200"><h3 class="text-xl font-semibold warm-neutral-text-primary mb-3">事件循環與任務層級</h3><p class="warm-neutral-text-secondary">要理解排程，必須知道簡化的<span class="keyword-interactive"data-keyword="event loop">事件循環</span>順序：<ol class="mt-2 space-y-1 text-sm"><li><strong>1. 目前 Task：</strong>執行同步腳本。<li><strong>2. <span class="keyword-interactive"data-keyword="microtasks">Microtasks</span>：</strong>執行所有 <code class="bg-gray-100 px-1.5 py-0.5 rounded">Promise.then</code>。<li><strong>3. 下一個 Task：</strong>從任務佇列中取出一個執行，如 <span class="keyword-interactive"data-keyword="MessageChannel">MessageChannel</span> 的回呼。<li><strong>4. (可能延遲)</strong> <span class="keyword-interactive"data-keyword="setTimeout">setTimeout</span> 的回呼。</ol></div></div></section><section id="interactive-demo"><h2 class="text-3xl font-bold text-center warm-neutral-text-primary mb-8">互動式範例：眼見為憑</h2><p class="text-center max-w-3xl mx-auto warm-neutral-text-secondary mb-10">點選下方按鈕，觀察在您目前的瀏覽器中，不同排程 API 的實際執行順序。您會清楚地看到 <code class="bg-gray-100 px-1.5 py-0.5 rounded">setTimeout</code> 的回呼通常會被延遲到最後執行。<div class="warm-neutral-card p-6 md:p-8 rounded-xl shadow-sm border border-gray-200"><div class="flex flex-col sm:flex-row items-center justify-between mb-6 gap-4"><h3 class="text-xl font-semibold warm-neutral-text-primary">排程順序示範</h3><button id="runDemoBtn"class="w-full sm:w-auto btn-primary warm-neutral-accent-bg text-white font-bold py-2 px-6 rounded-lg shadow-md">執行範例</button></div><div id="demoLog"class="bg-gray-50 p-4 rounded-lg font-mono text-sm text-gray-700 min-h-[200px] overflow-x-auto">點選按鈕開始...</div></div></section><section id="solution-comparison"><h2 class="text-3xl font-bold text-center warm-neutral-text-primary mb-8">解決方案：現代排程 API</h2><p class="text-center max-w-3xl mx-auto warm-neutral-text-secondary mb-10">為了給予開發者更精確的控制權，現代瀏覽器提供了更專門的 API。它們語意更清晰，且通常不會被<span class="keyword-interactive"data-keyword="clamping">節流</span>，是 <code class="bg-gray-100 px-1.5 py-0.5 rounded">setTimeout(0)</code> 的理想替代品。<div class="warm-neutral-card rounded-xl shadow-sm border border-gray-200 overflow-hidden"><div class="border-b border-gray-200"><nav class="flex -mb-px px-6"id="apiTabs"><button data-target="tab-posttask"class="tab-active text-left py-4 px-1 mr-8 text-sm font-medium">scheduler.postTask</button> <button data-target="tab-messagechannel"class="text-left py-4 px-1 mr-8 text-gray-500 hover:text-gray-700 text-sm font-medium">MessageChannel</button> <button data-target="tab-settimeout"class="text-left py-4 px-1 text-gray-500 hover:text-gray-700 text-sm font-medium">setTimeout</button></nav></div><div class="p-6 md:p-8"><div id="tab-posttask"class="tab-content"><h3 class="text-xl font-semibold warm-neutral-text-primary mb-3">首選：`scheduler.postTask`</h3><p class="warm-neutral-text-secondary mb-4">這是最新、語意最清晰的 API，專為精細的任務排程設計。它允許指定優先級（如 'user-blocking'），並與瀏覽器的渲染週期整合得更好。<ul class="space-y-2 text-sm"><li class="flex items-center"><span class="text-green-500 mr-2">✓</span><span><strong>優點：</strong>語意明確，可設定優先級，不會被<span class="keyword-interactive"data-keyword="clamping">節流</span>。</span><li class="flex items-center"><span class="text-red-500 mr-2">✗</span><span><strong>缺點：</strong>較新，部分舊版瀏覽器不支援。</span></ul></div><div id="tab-messagechannel"class="tab-content hidden"><h3 class="text-xl font-semibold warm-neutral-text-primary mb-3">次選：`MessageChannel`</h3><p class="warm-neutral-text-secondary mb-4">一個相對底層的 API，可用來建立兩個相互通訊的埠。向其中一個埠 <code class="bg-gray-100 px-1.5 py-0.5 rounded">postMessage</code> 會在任務佇列中新增一個任務，這個任務不會被<span class="keyword-interactive"data-keyword="clamping">節流</span>。這是目前跨瀏覽器相容性最好的高效排程方案。<ul class="space-y-2 text-sm"><li class="flex items-center"><span class="text-green-500 mr-2">✓</span><span><strong>優點：</strong>相容性好，速度快，能保證 FIFO 順序。</span><li class="flex items-center"><span class="text-red-500 mr-2">✗</span><span><strong>缺點：</strong>語法稍嫌繁瑣，需要手動管理 channel。</span></ul></div><div id="tab-settimeout"class="tab-content hidden"><h3 class="text-xl font-semibold warm-neutral-text-primary mb-3">保險：`setTimeout`</h3><p class="warm-neutral-text-secondary mb-4">作為最後的 fallback，它無處不在。但如前述，它不可靠，會被<span class="keyword-interactive"data-keyword="clamping">節流</span>，不應用於需要精確、立即執行的排程。<ul class="space-y-2 text-sm"><li class="flex items-center"><span class="text-green-500 mr-2">✓</span><span><strong>優點：</strong>100% 相容。</span><li class="flex items-center"><span class="text-red-500 mr-2">✗</span><span><strong>缺點：</strong>會被<span class="keyword-interactive"data-keyword="clamping">節流</span>，延遲不穩定，不適合精確排程。</span></ul></div></div></div></section><section id="best-practice"><h2 class="text-3xl font-bold text-center warm-neutral-text-primary mb-8">最佳實踐：穩健的 `nextTask` 實作</h2><p class="text-center max-w-3xl mx-auto warm-neutral-text-secondary mb-10">在 library 或大型應用中，建立一個抽象的排程函式是最佳實踐。以下是一個可以直接使用的 <code class="bg-gray-100 px-1.5 py-0.5 rounded">nextTask</code> 輔助函式，它會自動選擇最佳可用 API，並包含了針對 Safari 等特殊情況的保護機制。<div class="code-block"><button id="copyCodeBtn"class="copy-btn">複製</button><pre><code class="language-js">// nextTask(fn, ...args) -> 安排 fn 在目前 microtasks 後立即執行。
const nextTask = (() => {
  // 1) 優先使用 scheduler.postTask
  if (typeof scheduler !== 'undefined' && scheduler.postTask) {
    return (fn, ...args) => {
      const handle = { cancelled: false };
      scheduler.postTask(() => { if (!handle.cancelled) fn(...args); }, { priority: 'user-visible' });
      return { cancel: () => { handle.cancelled = true; } };
    };
  }

  // 2) MessageChannel + queue 作為 fallback
  try {
    const channel = new MessageChannel();
    const q = [];

    channel.port1.onmessage = () => {
      const item = q.shift();
      if (!item) return;
      const [fn, args] = item;
      try { fn(...args); } catch (e) { setTimeout(() => { throw e; }, 0); }
    };

    return (fn, ...args) => {
      // 安全閥：佇列過長時退回 setTimeout，避免極端情況下卡死
      if (q.length > 10000) {
        const t = setTimeout(fn, 0, ...args);
        return { cancel: () => clearTimeout(t) };
      }
      q.push([fn, args]);
      channel.port2.postMessage(null);
      // ... (此處可加入更精確的 cancel 邏輯)
    };
  } catch (e) {
    // MessageChannel 不可用時（如某些舊環境），繼續往下
  }

  // 3) 最後的保險：setTimeout(0)
  return (fn, ...args) => {
    const t = setTimeout(fn, 0, ...args);
    return { cancel: () => clearTimeout(t) };
  };
})();</code></pre></div></section></main><footer class="text-center mt-16 py-8 bg-white/50 border-t border-gray-200"><p class="text-sm warm-neutral-text-secondary"><a href="https://wellstsai.com"target="_blank"rel="noopener noreferrer"class="hover:text-blue-600 transition-colors">Generated by wellstsai.com</a></footer></div><div id="keyword-modal-container"class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden"><div id="modal-backdrop"class="fixed inset-0 bg-black/30 backdrop-blur-sm"></div><div id="modal-panel"class="relative z-10 w-full max-w-lg bg-white/70 backdrop-blur-xl border border-white/30 rounded-2xl shadow-2xl p-6 text-gray-800 modal-enter"><h3 id="modal-title"class="text-2xl font-bold mb-4 text-gray-900"></h3><div id="modal-content"class="text-base leading-relaxed space-y-4"></div><button id="modal-close-btn"class="absolute top-4 right-4 text-gray-500 hover:text-gray-800 transition-colors"><svg class="w-6 h-6"fill="none"stroke="currentColor"viewBox="0 0 24 24"xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round"stroke-linejoin="round"stroke-width="2"d="M6 18L18 6M6 6l12 12"></path></svg></button></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll();const e={setTimeout:{title:"setTimeout",content:'<p>一個廣泛使用的 Web API，用於在指定的延遲時間後執行一個函式或一段程式碼。它是非同步操作的基礎之一。</p><p>然而，<code>setTimeout(fn, 0)</code> 並不保證函式會立即執行。瀏覽器為了效能和電池壽命，會對其進行<strong class="font-semibold">節流（clamping）</strong>，最小延遲通常為 4ms 或更高。</p>'},clamping:{title:"節流 (Clamping)",content:"<p>指瀏覽器強制設定計時器（如 <code>setTimeout</code>）最小延遲時間的行為。這是 HTML 規範的一部分，旨在防止網頁過度使用計時器導致效能問題。</p><p>當一個頁面處於背景、或裝置處於省電模式時，這個最小延遲時間可能會被進一步提高，例如到 1000ms（1秒），以大幅減少資源消耗。</p>"},microtasks:{title:"Microtasks (微任務)",content:"<p>一個特殊的任務佇列，其優先級高於常規的 tasks（宏任務）。Microtasks 會在目前執行的腳本結束後、下一個 task 開始前，被立即清空。</p><p>最常見的 microtask 來源是 <code>Promise.then()</code>、<code>.catch()</code>、<code>.finally()</code> 的回呼函式，以及 <code>queueMicrotask()</code>。這使得它們非常適合執行需要在目前操作後立即進行的清理或更新工作。</p>"},"scheduler.postTask":{title:"scheduler.postTask",content:"<p>一個現代的瀏覽器 API，提供了一個更強大、更可預測的方式來排程任務。它旨在取代對 <code>setTimeout(0)</code> 的不當使用。</p><p>與 <code>setTimeout</code> 不同，<code>postTask</code> 不會被節流。它還允許開發者為任務指定優先級（例如 <code>'user-blocking'</code>, <code>'user-visible'</code>, <code>'background'</code>），讓瀏覽器能更智慧地安排工作，以確保流暢的使用者體驗。</p>"},MessageChannel:{title:"MessageChannel",content:'<p>一個 Web API，用於建立一個非同步的、雙向的通訊頻道。它包含兩個連接埠（<code>port1</code> 和 <code>port2</code>），可以互相傳送訊息。</p><p>當一個連接埠呼叫 <code>postMessage()</code> 時，它會在事件循環的 task 佇列中安排一個任務來傳遞訊息。這個過程不會被瀏覽器節流，因此 <code>MessageChannel</code> 成為了實現 un-clamped "setTimeout(0)" 的一種可靠且相容性良好的技術。</p>'},"event loop":{title:"Event Loop (事件循環)",content:"<p>JavaScript 非同步行為的核心機制。它是一個持續運行的過程，負責監控呼叫堆疊（call stack）和任務佇列（task queue）。</p><p>當呼叫堆疊為空時，事件循環會從任務佇列中取出一個任務並將其推入堆疊中執行。這個模型使得 JavaScript 引擎即使是單執行緒，也能處理 I/O、使用者互動等非同步操作而不會被阻塞。</p>"}},t=document.getElementById("main-content"),o=document.getElementById("keyword-modal-container"),n=document.getElementById("modal-panel"),s=document.getElementById("modal-backdrop"),c=document.getElementById("modal-title"),d=document.getElementById("modal-content"),a=document.getElementById("modal-close-btn");function l(){n.classList.remove("modal-enter"),n.classList.add("modal-leave"),t.classList.remove("blurred"),n.addEventListener("animationend",()=>{o.classList.add("hidden")},{once:!0})}document.addEventListener("click",s=>{const a=s.target.closest(".keyword-interactive");a&&a.dataset.keyword&&function(s){const a=e[s];a&&(c.textContent=a.title,d.innerHTML=a.content,o.classList.remove("hidden"),t.classList.add("blurred"),n.classList.remove("modal-leave"),n.classList.add("modal-enter"))}(a.dataset.keyword)}),a.addEventListener("click",l),s.addEventListener("click",l),document.addEventListener("keydown",e=>{"Escape"!==e.key||o.classList.contains("hidden")||l()});const i=(()=>{if("undefined"!=typeof scheduler&&scheduler.postTask)return(e,...t)=>scheduler.postTask(()=>e(...t),{priority:"user-visible"});try{const e=new MessageChannel,t=[];return e.port1.onmessage=()=>{const e=t.shift();if(e){const[t,o]=e;try{t(...o)}catch(e){setTimeout(()=>{throw e},0)}}},(o,...n)=>{t.push([o,n]),e.port2.postMessage(null)}}catch(e){}return(e,...t)=>setTimeout(e,0,...t)})(),r=document.getElementById("runDemoBtn"),m=document.getElementById("demoLog"),p=(e,t)=>{const o=document.createElement("div");o.className="log-entry mb-1 p-2 rounded";let n="bg-gray-200",s="同步腳本";"microtask"===t&&(n="bg-blue-100 text-blue-800",s="Microtask"),"task"===t&&(n="bg-green-100 text-green-800",s="Next Task"),"timeout"===t&&(n="bg-orange-100 text-orange-800",s="setTimeout");const c=(performance.now()-u).toFixed(2);o.innerHTML=`<span class="inline-block w-28 ${n} text-center text-xs font-semibold px-2 py-0.5 rounded-full">${s}</span><span class="ml-3">${e}</span><span class="float-right text-xs text-gray-400">+${c}ms</span>`,m.appendChild(o)};let u;r.addEventListener("click",()=>{m.innerHTML="",r.disabled=!0,r.textContent="執行中...",u=performance.now(),p("script start","sync"),Promise.resolve().then(()=>{p("microtask (Promise.then)","microtask")});let e="Unknown";"undefined"!=typeof scheduler&&scheduler.postTask?e="scheduler.postTask":"undefined"!=typeof MessageChannel&&(e="MessageChannel task"),i(()=>p(e,"task")),setTimeout(()=>{p("timeout (clamped)","timeout"),r.disabled=!1,r.textContent="重新執行"},0),p("script end","sync")});const g=document.querySelectorAll("#apiTabs button"),k=document.querySelectorAll(".tab-content");g.forEach(e=>{e.addEventListener("click",()=>{g.forEach(e=>{e.classList.remove("tab-active"),e.classList.add("text-gray-500","hover:text-gray-700")}),e.classList.add("tab-active"),e.classList.remove("text-gray-500","hover:text-gray-700"),k.forEach(e=>{e.classList.add("hidden")}),document.getElementById(e.dataset.target).classList.remove("hidden")})});const h=document.getElementById("copyCodeBtn"),y=document.querySelector(".code-block code");h.addEventListener("click",()=>{navigator.clipboard.writeText(y.innerText).then(()=>{h.textContent="已複製!",setTimeout(()=>{h.textContent="複製"},2e3)}).catch(e=>{h.textContent="複製失敗"})})})</script>